// generated by diplomat-tool
// dart format off

import 'dart:convert';
// ignore: unused_import
import 'dart:core' as core;
// ignore: unused_shown_name
import 'dart:core' show Object, String, bool, double, int, override;
import 'dart:ffi' as ffi;
// ignore: unused_import
import 'dart:typed_data';
import 'package:ffi/ffi.dart' as ffi2 show Arena, calloc;
import 'package:meta/meta.dart' as meta;
part 'Bidi.g.dart';
part 'BidiClass.g.dart';
part 'BidiDirection.g.dart';
part 'BidiInfo.g.dart';
part 'BidiMirroringGlyph.g.dart';
part 'BidiPairedBracketType.g.dart';
part 'BidiParagraph.g.dart';
part 'Calendar.g.dart';
part 'CalendarDateFromFieldsError.g.dart';
part 'CalendarError.g.dart';
part 'CalendarKind.g.dart';
part 'CanonicalCombiningClass.g.dart';
part 'CanonicalCombiningClassMap.g.dart';
part 'CanonicalComposition.g.dart';
part 'CanonicalDecomposition.g.dart';
part 'CaseMapCloser.g.dart';
part 'CaseMapper.g.dart';
part 'CodePointMapData16.g.dart';
part 'CodePointMapData8.g.dart';
part 'CodePointRangeIterator.g.dart';
part 'CodePointRangeIteratorResult.g.dart';
part 'CodePointSetBuilder.g.dart';
part 'CodePointSetData.g.dart';
part 'Collator.g.dart';
part 'CollatorAlternateHandling.g.dart';
part 'CollatorCaseFirst.g.dart';
part 'CollatorCaseLevel.g.dart';
part 'CollatorMaxVariable.g.dart';
part 'CollatorNumericOrdering.g.dart';
part 'CollatorOptions.g.dart';
part 'CollatorResolvedOptions.g.dart';
part 'CollatorStrength.g.dart';
part 'ComposingNormalizer.g.dart';
part 'DataError.g.dart';
part 'DataProvider.g.dart';
part 'Date.g.dart';
part 'DateFields.g.dart';
part 'DateFormatter.g.dart';
part 'DateFormatterGregorian.g.dart';
part 'DateFromFieldsOptions.g.dart';
part 'DateMissingFieldsStrategy.g.dart';
part 'DateOverflow.g.dart';
part 'DateTime.g.dart';
part 'DateTimeAlignment.g.dart';
part 'DateTimeFormatter.g.dart';
part 'DateTimeFormatterGregorian.g.dart';
part 'DateTimeFormatterLoadError.g.dart';
part 'DateTimeLength.g.dart';
part 'DateTimeMismatchedCalendarError.g.dart';
part 'DateTimeWriteError.g.dart';
part 'Decimal.g.dart';
part 'DecimalFormatter.g.dart';
part 'DecimalGroupingStrategy.g.dart';
part 'DecimalLimitError.g.dart';
part 'DecimalParseError.g.dart';
part 'DecimalRoundingIncrement.g.dart';
part 'DecimalSign.g.dart';
part 'DecimalSignDisplay.g.dart';
part 'DecimalSignedRoundingMode.g.dart';
part 'Decomposed.g.dart';
part 'DecomposingNormalizer.g.dart';
part 'DisplayNamesFallback.g.dart';
part 'DisplayNamesOptions.g.dart';
part 'DisplayNamesStyle.g.dart';
part 'EastAsianWidth.g.dart';
part 'EmojiSetData.g.dart';
part 'ExemplarCharacters.g.dart';
part 'GeneralCategory.g.dart';
part 'GeneralCategoryGroup.g.dart';
part 'GeneralCategoryNameToGroupMapper.g.dart';
part 'GraphemeClusterBreak.g.dart';
part 'GraphemeClusterBreakIteratorLatin1.g.dart';
part 'GraphemeClusterBreakIteratorUtf16.g.dart';
part 'GraphemeClusterBreakIteratorUtf8.g.dart';
part 'GraphemeClusterSegmenter.g.dart';
part 'HangulSyllableType.g.dart';
part 'IanaParser.g.dart';
part 'IanaParserExtended.g.dart';
part 'IndicConjunctBreak.g.dart';
part 'IndicSyllabicCategory.g.dart';
part 'IsoDate.g.dart';
part 'IsoDateTime.g.dart';
part 'IsoWeekOfYear.g.dart';
part 'JoiningGroup.g.dart';
part 'JoiningType.g.dart';
part 'LanguageDisplay.g.dart';
part 'LeadingAdjustment.g.dart';
part 'LineBreak.g.dart';
part 'LineBreakIteratorLatin1.g.dart';
part 'LineBreakIteratorUtf16.g.dart';
part 'LineBreakIteratorUtf8.g.dart';
part 'LineBreakOptions.g.dart';
part 'LineBreakStrictness.g.dart';
part 'LineBreakWordOption.g.dart';
part 'LineSegmenter.g.dart';
part 'ListFormatter.g.dart';
part 'ListLength.g.dart';
part 'Locale.g.dart';
part 'LocaleCanonicalizer.g.dart';
part 'LocaleDirection.g.dart';
part 'LocaleDirectionality.g.dart';
part 'LocaleDisplayNamesFormatter.g.dart';
part 'LocaleExpander.g.dart';
part 'LocaleFallbackConfig.g.dart';
part 'LocaleFallbackIterator.g.dart';
part 'LocaleFallbackPriority.g.dart';
part 'LocaleFallbacker.g.dart';
part 'LocaleFallbackerWithConfig.g.dart';
part 'LocaleParseError.g.dart';
part 'Logger.g.dart';
part 'NumericType.g.dart';
part 'PluralCategories.g.dart';
part 'PluralCategory.g.dart';
part 'PluralOperands.g.dart';
part 'PluralRules.g.dart';
part 'PluralRulesWithRanges.g.dart';
part 'PropertyValueNameToEnumMapper.g.dart';
part 'RegionDisplayNames.g.dart';
part 'ReorderedIndexMap.g.dart';
part 'Rfc9557ParseError.g.dart';
part 'Script.g.dart';
part 'ScriptExtensionsSet.g.dart';
part 'ScriptWithExtensions.g.dart';
part 'ScriptWithExtensionsBorrowed.g.dart';
part 'SegmenterWordType.g.dart';
part 'SentenceBreak.g.dart';
part 'SentenceBreakIteratorLatin1.g.dart';
part 'SentenceBreakIteratorUtf16.g.dart';
part 'SentenceBreakIteratorUtf8.g.dart';
part 'SentenceSegmenter.g.dart';
part 'Time.g.dart';
part 'TimeFormatter.g.dart';
part 'TimePrecision.g.dart';
part 'TimeZone.g.dart';
part 'TimeZoneAndCanonical.g.dart';
part 'TimeZoneAndCanonicalAndNormalized.g.dart';
part 'TimeZoneAndCanonicalAndNormalizedIterator.g.dart';
part 'TimeZoneAndCanonicalIterator.g.dart';
part 'TimeZoneFormatter.g.dart';
part 'TimeZoneInfo.g.dart';
part 'TimeZoneInvalidOffsetError.g.dart';
part 'TimeZoneIterator.g.dart';
part 'TitlecaseMapper.g.dart';
part 'TitlecaseOptions.g.dart';
part 'TrailingCase.g.dart';
part 'TransformResult.g.dart';
part 'UtcOffset.g.dart';
part 'VariantOffsets.g.dart';
part 'VerticalOrientation.g.dart';
part 'WeekInformation.g.dart';
part 'Weekday.g.dart';
part 'WeekdaySetIterator.g.dart';
part 'WindowsParser.g.dart';
part 'WordBreak.g.dart';
part 'WordBreakIteratorLatin1.g.dart';
part 'WordBreakIteratorUtf16.g.dart';
part 'WordBreakIteratorUtf8.g.dart';
part 'WordSegmenter.g.dart';
part 'YearStyle.g.dart';
part 'ZonedDateFormatter.g.dart';
part 'ZonedDateFormatterGregorian.g.dart';
part 'ZonedDateTime.g.dart';
part 'ZonedDateTimeFormatter.g.dart';
part 'ZonedDateTimeFormatterGregorian.g.dart';
part 'ZonedIsoDateTime.g.dart';
part 'ZonedTime.g.dart';
part 'ZonedTimeFormatter.g.dart';

// ignore: experimental_member_use
@meta.RecordUse()
class _DiplomatFfiUse {
  final String symbol;

  // ignore: experimental_member_use
  const _DiplomatFfiUse(@meta.mustBeConst this.symbol);
}

/// A [Rune] is a Unicode code point, such as `a`, or `ðŸ’¡`.
///
/// The recommended way to obtain a [Rune] is to create it from a
/// [String], which is conceptually a sequence of [Rune]s. For
/// example, `'a'.runes.first` is equal to the [Rune] `a`.
///
/// Dart does not have a character/rune literal (https://github.com/dart-lang/language/issues/886),
/// so integer literals need to be used. For example the Unicode code point
/// U+1F4A1, `ðŸ’¡`, can be represented by `0x1F4A1`.
///
/// A [String] can be constructed from a [Rune] using (the [confusingly named](
/// https://github.com/dart-lang/sdk/issues/56304)) [String.fromCharCode].
typedef Rune = int;

// ignore: unused_element
final _callocFree = core.Finalizer(ffi2.calloc.free);

// ignore: unused_element
final _nopFree = core.Finalizer((nothing) => {});

// ignore: unused_element
final _rustFree = core.Finalizer(
  (({ffi.Pointer<ffi.Void> pointer, int bytes, int align}) record) =>
      _diplomat_free(record.pointer, record.bytes, record.align),
);

// ignore: unused_element
final class _RustAlloc implements ffi.Allocator {
  @override
  ffi.Pointer<T> allocate<T extends ffi.NativeType>(
    int byteCount, {
    int? alignment,
  }) {
    return _diplomat_alloc(byteCount, alignment ?? 1).cast();
  }

  @override
  void free(ffi.Pointer<ffi.NativeType> pointer) {
    throw 'Internal error: should not deallocate in Rust memory';
  }
}

@_DiplomatFfiUse('diplomat_alloc')
@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>(
  symbol: 'diplomat_alloc',
  isLeaf: true,
)
// ignore: non_constant_identifier_names
external ffi.Pointer<ffi.Void> _diplomat_alloc(int len, int align);

@_DiplomatFfiUse('diplomat_free')
@ffi.Native<ffi.Size Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size)>(
  symbol: 'diplomat_free',
  isLeaf: true,
)
// ignore: non_constant_identifier_names
external int _diplomat_free(ffi.Pointer<ffi.Void> ptr, int len, int align);

// ignore: unused_element
class _FinalizedArena {
  final ffi2.Arena arena;
  static final core.Finalizer<ffi2.Arena> _finalizer = core.Finalizer(
    (arena) => arena.releaseAll(),
  );

  // ignore: unused_element
  _FinalizedArena() : arena = ffi2.Arena() {
    _finalizer.attach(this, arena);
  }

  // ignore: unused_element
  _FinalizedArena.withLifetime(core.List<core.List<Object>> lifetimeAppendArray)
    : arena = ffi2.Arena() {
    _finalizer.attach(this, arena);
    for (final edge in lifetimeAppendArray) {
      edge.add(this);
    }
  }
}

final class _ResultDateTimeFfiInt32Union extends ffi.Union {
  external _DateTimeFfi ok;

  @ffi.Int32()
  external int err;
}

final class _ResultDateTimeFfiInt32 extends ffi.Struct {
  external _ResultDateTimeFfiInt32Union union;

  @ffi.Bool()
  external bool isOk;

  // ignore: unused_element
  factory _ResultDateTimeFfiInt32.ok(_DateTimeFfi val) {
    final struct = ffi.Struct.create<_ResultDateTimeFfiInt32>();
    struct.isOk = true;
    struct.union.ok = val;
    return struct;
  }
  // ignore: unused_element
  factory _ResultDateTimeFfiInt32.err(int val) {
    final struct = ffi.Struct.create<_ResultDateTimeFfiInt32>();
    struct.isOk = false;
    struct.union.err = val;
    return struct;
  }
}

final class _ResultInt32VoidUnion extends ffi.Union {
  @ffi.Int32()
  external int ok;

}

final class _ResultInt32Void extends ffi.Struct {
  external _ResultInt32VoidUnion union;

  @ffi.Bool()
  external bool isOk;

  // ignore: unused_element
  factory _ResultInt32Void.ok(int val) {
    final struct = ffi.Struct.create<_ResultInt32Void>();
    struct.isOk = true;
    struct.union.ok = val;
    return struct;
  }
  // ignore: unused_element
  factory _ResultInt32Void.err() {
    final struct = ffi.Struct.create<_ResultInt32Void>();
    struct.isOk = false;
    return struct;
  }
}

final class _ResultIsoDateTimeFfiInt32Union extends ffi.Union {
  external _IsoDateTimeFfi ok;

  @ffi.Int32()
  external int err;
}

final class _ResultIsoDateTimeFfiInt32 extends ffi.Struct {
  external _ResultIsoDateTimeFfiInt32Union union;

  @ffi.Bool()
  external bool isOk;

  // ignore: unused_element
  factory _ResultIsoDateTimeFfiInt32.ok(_IsoDateTimeFfi val) {
    final struct = ffi.Struct.create<_ResultIsoDateTimeFfiInt32>();
    struct.isOk = true;
    struct.union.ok = val;
    return struct;
  }
  // ignore: unused_element
  factory _ResultIsoDateTimeFfiInt32.err(int val) {
    final struct = ffi.Struct.create<_ResultIsoDateTimeFfiInt32>();
    struct.isOk = false;
    struct.union.err = val;
    return struct;
  }
}

final class _ResultIsoDateTimeFfiVoidUnion extends ffi.Union {
  external _IsoDateTimeFfi ok;

}

final class _ResultIsoDateTimeFfiVoid extends ffi.Struct {
  external _ResultIsoDateTimeFfiVoidUnion union;

  @ffi.Bool()
  external bool isOk;

  // ignore: unused_element
  factory _ResultIsoDateTimeFfiVoid.ok(_IsoDateTimeFfi val) {
    final struct = ffi.Struct.create<_ResultIsoDateTimeFfiVoid>();
    struct.isOk = true;
    struct.union.ok = val;
    return struct;
  }
  // ignore: unused_element
  factory _ResultIsoDateTimeFfiVoid.err() {
    final struct = ffi.Struct.create<_ResultIsoDateTimeFfiVoid>();
    struct.isOk = false;
    return struct;
  }
}

final class _ResultOpaqueDecimalLimitErrorFfiUnion extends ffi.Union {
  external ffi.Pointer<ffi.Opaque> ok;

}

final class _ResultOpaqueDecimalLimitErrorFfi extends ffi.Struct {
  external _ResultOpaqueDecimalLimitErrorFfiUnion union;

  @ffi.Bool()
  external bool isOk;

  // ignore: unused_element
  factory _ResultOpaqueDecimalLimitErrorFfi.ok(ffi.Pointer<ffi.Opaque> val) {
    final struct = ffi.Struct.create<_ResultOpaqueDecimalLimitErrorFfi>();
    struct.isOk = true;
    struct.union.ok = val;
    return struct;
  }
  // ignore: unused_element
  factory _ResultOpaqueDecimalLimitErrorFfi.err() {
    final struct = ffi.Struct.create<_ResultOpaqueDecimalLimitErrorFfi>();
    struct.isOk = false;
    return struct;
  }
}

final class _ResultOpaqueInt32Union extends ffi.Union {
  external ffi.Pointer<ffi.Opaque> ok;

  @ffi.Int32()
  external int err;
}

final class _ResultOpaqueInt32 extends ffi.Struct {
  external _ResultOpaqueInt32Union union;

  @ffi.Bool()
  external bool isOk;

  // ignore: unused_element
  factory _ResultOpaqueInt32.ok(ffi.Pointer<ffi.Opaque> val) {
    final struct = ffi.Struct.create<_ResultOpaqueInt32>();
    struct.isOk = true;
    struct.union.ok = val;
    return struct;
  }
  // ignore: unused_element
  factory _ResultOpaqueInt32.err(int val) {
    final struct = ffi.Struct.create<_ResultOpaqueInt32>();
    struct.isOk = false;
    struct.union.err = val;
    return struct;
  }
}

final class _ResultOpaqueTimeZoneInvalidOffsetErrorFfiUnion extends ffi.Union {
  external ffi.Pointer<ffi.Opaque> ok;

}

final class _ResultOpaqueTimeZoneInvalidOffsetErrorFfi extends ffi.Struct {
  external _ResultOpaqueTimeZoneInvalidOffsetErrorFfiUnion union;

  @ffi.Bool()
  external bool isOk;

  // ignore: unused_element
  factory _ResultOpaqueTimeZoneInvalidOffsetErrorFfi.ok(ffi.Pointer<ffi.Opaque> val) {
    final struct = ffi.Struct.create<_ResultOpaqueTimeZoneInvalidOffsetErrorFfi>();
    struct.isOk = true;
    struct.union.ok = val;
    return struct;
  }
  // ignore: unused_element
  factory _ResultOpaqueTimeZoneInvalidOffsetErrorFfi.err() {
    final struct = ffi.Struct.create<_ResultOpaqueTimeZoneInvalidOffsetErrorFfi>();
    struct.isOk = false;
    return struct;
  }
}

final class _ResultSliceUtf8VoidUnion extends ffi.Union {
  external _SliceUtf8 ok;

}

final class _ResultSliceUtf8Void extends ffi.Struct {
  external _ResultSliceUtf8VoidUnion union;

  @ffi.Bool()
  external bool isOk;

  // ignore: unused_element
  factory _ResultSliceUtf8Void.ok(_SliceUtf8 val) {
    final struct = ffi.Struct.create<_ResultSliceUtf8Void>();
    struct.isOk = true;
    struct.union.ok = val;
    return struct;
  }
  // ignore: unused_element
  factory _ResultSliceUtf8Void.err() {
    final struct = ffi.Struct.create<_ResultSliceUtf8Void>();
    struct.isOk = false;
    return struct;
  }
}

final class _ResultTimeZoneAndCanonicalAndNormalizedFfiVoidUnion extends ffi.Union {
  external _TimeZoneAndCanonicalAndNormalizedFfi ok;

}

final class _ResultTimeZoneAndCanonicalAndNormalizedFfiVoid extends ffi.Struct {
  external _ResultTimeZoneAndCanonicalAndNormalizedFfiVoidUnion union;

  @ffi.Bool()
  external bool isOk;

  // ignore: unused_element
  factory _ResultTimeZoneAndCanonicalAndNormalizedFfiVoid.ok(_TimeZoneAndCanonicalAndNormalizedFfi val) {
    final struct = ffi.Struct.create<_ResultTimeZoneAndCanonicalAndNormalizedFfiVoid>();
    struct.isOk = true;
    struct.union.ok = val;
    return struct;
  }
  // ignore: unused_element
  factory _ResultTimeZoneAndCanonicalAndNormalizedFfiVoid.err() {
    final struct = ffi.Struct.create<_ResultTimeZoneAndCanonicalAndNormalizedFfiVoid>();
    struct.isOk = false;
    return struct;
  }
}

final class _ResultTimeZoneAndCanonicalFfiVoidUnion extends ffi.Union {
  external _TimeZoneAndCanonicalFfi ok;

}

final class _ResultTimeZoneAndCanonicalFfiVoid extends ffi.Struct {
  external _ResultTimeZoneAndCanonicalFfiVoidUnion union;

  @ffi.Bool()
  external bool isOk;

  // ignore: unused_element
  factory _ResultTimeZoneAndCanonicalFfiVoid.ok(_TimeZoneAndCanonicalFfi val) {
    final struct = ffi.Struct.create<_ResultTimeZoneAndCanonicalFfiVoid>();
    struct.isOk = true;
    struct.union.ok = val;
    return struct;
  }
  // ignore: unused_element
  factory _ResultTimeZoneAndCanonicalFfiVoid.err() {
    final struct = ffi.Struct.create<_ResultTimeZoneAndCanonicalFfiVoid>();
    struct.isOk = false;
    return struct;
  }
}

final class _ResultUint16VoidUnion extends ffi.Union {
  @ffi.Uint16()
  external int ok;

}

final class _ResultUint16Void extends ffi.Struct {
  external _ResultUint16VoidUnion union;

  @ffi.Bool()
  external bool isOk;

  // ignore: unused_element
  factory _ResultUint16Void.ok(int val) {
    final struct = ffi.Struct.create<_ResultUint16Void>();
    struct.isOk = true;
    struct.union.ok = val;
    return struct;
  }
  // ignore: unused_element
  factory _ResultUint16Void.err() {
    final struct = ffi.Struct.create<_ResultUint16Void>();
    struct.isOk = false;
    return struct;
  }
}

final class _ResultUint32VoidUnion extends ffi.Union {
  @ffi.Uint32()
  external Rune ok;

}

final class _ResultUint32Void extends ffi.Struct {
  external _ResultUint32VoidUnion union;

  @ffi.Bool()
  external bool isOk;

  // ignore: unused_element
  factory _ResultUint32Void.ok(Rune val) {
    final struct = ffi.Struct.create<_ResultUint32Void>();
    struct.isOk = true;
    struct.union.ok = val;
    return struct;
  }
  // ignore: unused_element
  factory _ResultUint32Void.err() {
    final struct = ffi.Struct.create<_ResultUint32Void>();
    struct.isOk = false;
    return struct;
  }
}

final class _ResultUint8VoidUnion extends ffi.Union {
  @ffi.Uint8()
  external int ok;

}

final class _ResultUint8Void extends ffi.Struct {
  external _ResultUint8VoidUnion union;

  @ffi.Bool()
  external bool isOk;

  // ignore: unused_element
  factory _ResultUint8Void.ok(int val) {
    final struct = ffi.Struct.create<_ResultUint8Void>();
    struct.isOk = true;
    struct.union.ok = val;
    return struct;
  }
  // ignore: unused_element
  factory _ResultUint8Void.err() {
    final struct = ffi.Struct.create<_ResultUint8Void>();
    struct.isOk = false;
    return struct;
  }
}

final class _ResultVoidDateTimeMismatchedCalendarErrorFfiUnion extends ffi.Union {

  external _DateTimeMismatchedCalendarErrorFfi err;
}

final class _ResultVoidDateTimeMismatchedCalendarErrorFfi extends ffi.Struct {
  external _ResultVoidDateTimeMismatchedCalendarErrorFfiUnion union;

  @ffi.Bool()
  external bool isOk;

  // ignore: unused_element
  factory _ResultVoidDateTimeMismatchedCalendarErrorFfi.ok() {
    final struct = ffi.Struct.create<_ResultVoidDateTimeMismatchedCalendarErrorFfi>();
    struct.isOk = true;
    return struct;
  }
  // ignore: unused_element
  factory _ResultVoidDateTimeMismatchedCalendarErrorFfi.err(_DateTimeMismatchedCalendarErrorFfi val) {
    final struct = ffi.Struct.create<_ResultVoidDateTimeMismatchedCalendarErrorFfi>();
    struct.isOk = false;
    struct.union.err = val;
    return struct;
  }
}

final class _ResultVoidInt32Union extends ffi.Union {

  @ffi.Int32()
  external int err;
}

final class _ResultVoidInt32 extends ffi.Struct {
  external _ResultVoidInt32Union union;

  @ffi.Bool()
  external bool isOk;

  // ignore: unused_element
  factory _ResultVoidInt32.ok() {
    final struct = ffi.Struct.create<_ResultVoidInt32>();
    struct.isOk = true;
    return struct;
  }
  // ignore: unused_element
  factory _ResultVoidInt32.err(int val) {
    final struct = ffi.Struct.create<_ResultVoidInt32>();
    struct.isOk = false;
    struct.union.err = val;
    return struct;
  }
}

final class _ResultVoidVoid extends ffi.Struct {

  @ffi.Bool()
  external bool isOk;

  // ignore: unused_element
  factory _ResultVoidVoid.ok() {
    final struct = ffi.Struct.create<_ResultVoidVoid>();
    struct.isOk = true;
    return struct;
  }
  // ignore: unused_element
  factory _ResultVoidVoid.err() {
    final struct = ffi.Struct.create<_ResultVoidVoid>();
    struct.isOk = false;
    return struct;
  }
}

final class _ResultZonedDateTimeFfiInt32Union extends ffi.Union {
  external _ZonedDateTimeFfi ok;

  @ffi.Int32()
  external int err;
}

final class _ResultZonedDateTimeFfiInt32 extends ffi.Struct {
  external _ResultZonedDateTimeFfiInt32Union union;

  @ffi.Bool()
  external bool isOk;

  // ignore: unused_element
  factory _ResultZonedDateTimeFfiInt32.ok(_ZonedDateTimeFfi val) {
    final struct = ffi.Struct.create<_ResultZonedDateTimeFfiInt32>();
    struct.isOk = true;
    struct.union.ok = val;
    return struct;
  }
  // ignore: unused_element
  factory _ResultZonedDateTimeFfiInt32.err(int val) {
    final struct = ffi.Struct.create<_ResultZonedDateTimeFfiInt32>();
    struct.isOk = false;
    struct.union.err = val;
    return struct;
  }
}

final class _ResultZonedIsoDateTimeFfiInt32Union extends ffi.Union {
  external _ZonedIsoDateTimeFfi ok;

  @ffi.Int32()
  external int err;
}

final class _ResultZonedIsoDateTimeFfiInt32 extends ffi.Struct {
  external _ResultZonedIsoDateTimeFfiInt32Union union;

  @ffi.Bool()
  external bool isOk;

  // ignore: unused_element
  factory _ResultZonedIsoDateTimeFfiInt32.ok(_ZonedIsoDateTimeFfi val) {
    final struct = ffi.Struct.create<_ResultZonedIsoDateTimeFfiInt32>();
    struct.isOk = true;
    struct.union.ok = val;
    return struct;
  }
  // ignore: unused_element
  factory _ResultZonedIsoDateTimeFfiInt32.err(int val) {
    final struct = ffi.Struct.create<_ResultZonedIsoDateTimeFfiInt32>();
    struct.isOk = false;
    struct.union.err = val;
    return struct;
  }
}

final class _ResultZonedTimeFfiInt32Union extends ffi.Union {
  external _ZonedTimeFfi ok;

  @ffi.Int32()
  external int err;
}

final class _ResultZonedTimeFfiInt32 extends ffi.Struct {
  external _ResultZonedTimeFfiInt32Union union;

  @ffi.Bool()
  external bool isOk;

  // ignore: unused_element
  factory _ResultZonedTimeFfiInt32.ok(_ZonedTimeFfi val) {
    final struct = ffi.Struct.create<_ResultZonedTimeFfiInt32>();
    struct.isOk = true;
    struct.union.ok = val;
    return struct;
  }
  // ignore: unused_element
  factory _ResultZonedTimeFfiInt32.err(int val) {
    final struct = ffi.Struct.create<_ResultZonedTimeFfiInt32>();
    struct.isOk = false;
    struct.union.err = val;
    return struct;
  }
}

final class _SliceRune extends ffi.Struct {
  external ffi.Pointer<ffi.Uint32> _data;

  @ffi.Size()
  external int _length;

  // This is expensive
  @override
  bool operator ==(Object other) {
    if (other is! _SliceRune || other._length != _length) {
      return false;
    }

    for (var i = 0; i < _length; i++) {
      if (other._data[i] != _data[i]) {
        return false;
      }
    }
    return true;
  }

  // This is cheap
  @override
  int get hashCode => _length.hashCode;

  // ignore: unused_element
  core.List<Rune> _toDart(core.List<Object> lifetimeEdges, {bool isStatic = false}) {
    final r = _data.asTypedList(_length);
    if (lifetimeEdges.isEmpty && !isStatic) {
      _rustFree.attach(r, (pointer: _data.cast(), bytes: _length, align: 1));
    } else {
      _nopFree.attach(r, lifetimeEdges); // Keep lifetime edges alive
    }
    return r;
  }
}

extension on core.List<Rune> {
  // ignore: unused_element
  _SliceRune _uint32AllocIn(ffi.Allocator alloc) {
    final slice = ffi.Struct.create<_SliceRune>();
    slice._data = alloc(length)..asTypedList(length).setRange(0, length, this);
    slice._length = length;
    return slice;
  }
}

final class _SliceSliceUtf16 extends ffi.Struct {
  external ffi.Pointer<_SliceUtf16> _data;

  @ffi.Size()
  external int _length;

  // This is expensive
  @override
  bool operator ==(Object other) {
    if (other is! _SliceSliceUtf16 || other._length != _length) {
      return false;
    }

    for (var i = 0; i < _length; i++) {
      if (other._data[i] != _data[i]) {
        return false;
      }
    }
    return true;
  }

  // This is cheap
  @override
  int get hashCode => _length.hashCode;

  // ignore: unused_element
  core.List<core.String> _toDart(core.List<Object> lifetimeEdges, {bool isStatic = false}) {
    final r = core.Iterable.generate(_length, (i) => _data[i]._toDart(lifetimeEdges)).toList(growable: false);
    if (lifetimeEdges.isEmpty && !isStatic) {
      // unsupported
    } else {
      // Lifetime edges will be cleaned up
    }
    return r;
  }
}

extension on core.List<core.String> {
  // ignore: unused_element
  _SliceSliceUtf16 _utf16SliceAllocIn(ffi.Allocator alloc) {
    final slice = ffi.Struct.create<_SliceSliceUtf16>();
    slice._data = alloc(length);
    for (var i = 0; i < length; i++) {
      slice._data[i] = this[i]._utf16AllocIn(alloc);
    }
    slice._length = length;
    return slice;
  }
}

final class _SliceUint8 extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> _data;

  @ffi.Size()
  external int _length;

  // This is expensive
  @override
  bool operator ==(Object other) {
    if (other is! _SliceUint8 || other._length != _length) {
      return false;
    }

    for (var i = 0; i < _length; i++) {
      if (other._data[i] != _data[i]) {
        return false;
      }
    }
    return true;
  }

  // This is cheap
  @override
  int get hashCode => _length.hashCode;

  // ignore: unused_element
  core.List<int> _toDart(core.List<Object> lifetimeEdges, {bool isStatic = false}) {
    final r = _data.asTypedList(_length);
    if (lifetimeEdges.isEmpty && !isStatic) {
      _rustFree.attach(r, (pointer: _data.cast(), bytes: _length, align: 1));
    } else {
      _nopFree.attach(r, lifetimeEdges); // Keep lifetime edges alive
    }
    return r;
  }
}

extension on core.List<int> {
  // ignore: unused_element
  _SliceUint8 _uint8AllocIn(ffi.Allocator alloc) {
    final slice = ffi.Struct.create<_SliceUint8>();
    slice._data = alloc(length);
    for (var i = 0; i < length; i++) {
      slice._data[i] = this[i].clamp(0, 255);
    }
    slice._length = length;
    return slice;
  }
}

final class _SliceUsize extends ffi.Struct {
  external ffi.Pointer<ffi.Size> _data;

  @ffi.Size()
  external int _length;

  // This is expensive
  @override
  bool operator ==(Object other) {
    if (other is! _SliceUsize || other._length != _length) {
      return false;
    }

    for (var i = 0; i < _length; i++) {
      if (other._data[i] != _data[i]) {
        return false;
      }
    }
    return true;
  }

  // This is cheap
  @override
  int get hashCode => _length.hashCode;

  // ignore: unused_element
  core.List<int> _toDart(core.List<Object> lifetimeEdges, {bool isStatic = false}) {
    final r = core.Iterable.generate(_length, (i) => _data[i]).toList(growable: false);
    if (lifetimeEdges.isEmpty && !isStatic) {
      _diplomat_free(_data.cast(), _length * ffi.sizeOf<ffi.Size>(), ffi.sizeOf<ffi.Size>());
    } else {
      // Lifetime edges will be cleaned up
    }
    return r;
  }
}

extension on core.List<int> {
  // ignore: unused_element
  _SliceUsize _usizeAllocIn(ffi.Allocator alloc) {
    final slice = ffi.Struct.create<_SliceUsize>();
    slice._data = alloc(length);
    for (var i = 0; i < length; i++) {
      slice._data[i] = this[i] < 0 ? 0 : this[i];
    }
    slice._length = length;
    return slice;
  }
}

final class _SliceUtf16 extends ffi.Struct {
  external ffi.Pointer<ffi.Uint16> _data;

  @ffi.Size()
  external int _length;

  // This is expensive
  @override
  bool operator ==(Object other) {
    if (other is! _SliceUtf16 || other._length != _length) {
      return false;
    }

    for (var i = 0; i < _length; i++) {
      if (other._data[i] != _data[i]) {
        return false;
      }
    }
    return true;
  }

  // This is cheap
  @override
  int get hashCode => _length.hashCode;

  // ignore: unused_element
  String _toDart(core.List<Object> lifetimeEdges, {bool isStatic = false}) {
    final r = core.String.fromCharCodes(_data.asTypedList(_length));
    if (lifetimeEdges.isEmpty && !isStatic) {
      _diplomat_free(_data.cast(), _length * 2, 2);
    } else {
      // Lifetime edges will be cleaned up
    }
    return r;
  }
}

extension on String {
  // ignore: unused_element
  _SliceUtf16 _utf16AllocIn(ffi.Allocator alloc) {
    final slice = ffi.Struct.create<_SliceUtf16>();
    slice._data = alloc(codeUnits.length)..asTypedList(codeUnits.length).setRange(0, codeUnits.length, codeUnits);
    slice._length = length;
    return slice;
  }
}

final class _SliceUtf8 extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> _data;

  @ffi.Size()
  external int _length;

  // This is expensive
  @override
  bool operator ==(Object other) {
    if (other is! _SliceUtf8 || other._length != _length) {
      return false;
    }

    for (var i = 0; i < _length; i++) {
      if (other._data[i] != _data[i]) {
        return false;
      }
    }
    return true;
  }

  // This is cheap
  @override
  int get hashCode => _length.hashCode;

  // ignore: unused_element
  String _toDart(core.List<Object> lifetimeEdges, {bool isStatic = false}) {
    final r = const Utf8Decoder().convert(_data.asTypedList(_length));
    if (lifetimeEdges.isEmpty && !isStatic) {
      _diplomat_free(_data.cast(), _length, 1);
    } else {
      // Lifetime edges will be cleaned up
    }
    return r;
  }
}

extension on String {
  // ignore: unused_element
  _SliceUtf8 _utf8AllocIn(ffi.Allocator alloc) {
    final slice = ffi.Struct.create<_SliceUtf8>();
    final encoded = const Utf8Encoder().convert(this);
    slice._data = alloc(encoded.length)..asTypedList(encoded.length).setRange(0, encoded.length, encoded);
    slice._length = encoded.length;
    return slice;
  }
}

final class _Write {
  final ffi.Pointer<ffi.Opaque> _ffi;

  _Write() : _ffi = _diplomat_buffer_write_create(0);

  String finalize() {
    try {
      final buf = _diplomat_buffer_write_get_bytes(_ffi);
      if (buf == ffi.Pointer.fromAddress(0)) {
        throw const core.OutOfMemoryError();
      }
      return const Utf8Decoder().convert(buf.asTypedList(_diplomat_buffer_write_len(_ffi)));
    } finally {
      _diplomat_buffer_write_destroy(_ffi);
    }
  }
}

@_DiplomatFfiUse('diplomat_buffer_write_create')
@ffi.Native<ffi.Pointer<ffi.Opaque> Function(ffi.Size)>(symbol: 'diplomat_buffer_write_create', isLeaf: true)
// ignore: non_constant_identifier_names
external ffi.Pointer<ffi.Opaque> _diplomat_buffer_write_create(int len);

@_DiplomatFfiUse('diplomat_buffer_write_len')
@ffi.Native<ffi.Size Function(ffi.Pointer<ffi.Opaque>)>(symbol: 'diplomat_buffer_write_len', isLeaf: true)
// ignore: non_constant_identifier_names
external int _diplomat_buffer_write_len(ffi.Pointer<ffi.Opaque> ptr);

@_DiplomatFfiUse('diplomat_buffer_write_get_bytes')
@ffi.Native<ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<ffi.Opaque>)>(symbol: 'diplomat_buffer_write_get_bytes', isLeaf: true)
// ignore: non_constant_identifier_names
external ffi.Pointer<ffi.Uint8> _diplomat_buffer_write_get_bytes(ffi.Pointer<ffi.Opaque> ptr);

@_DiplomatFfiUse('diplomat_buffer_write_destroy')
@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Opaque>)>(symbol: 'diplomat_buffer_write_destroy', isLeaf: true)
// ignore: non_constant_identifier_names
external void _diplomat_buffer_write_destroy(ffi.Pointer<ffi.Opaque> ptr);

// dart format on
