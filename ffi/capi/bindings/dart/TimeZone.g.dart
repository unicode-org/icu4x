// generated by diplomat-tool

part of 'lib.g.dart';

/// See the [Rust documentation for `TimeZone`](https://docs.rs/icu/latest/icu/timezone/struct.TimeZone.html) for more information.
final class TimeZone implements ffi.Finalizable {
  final ffi.Pointer<ffi.Opaque> _ffi;

  // These are "used" in the sense that they keep dependencies alive
  // ignore: unused_field
  final core.List<Object> _selfEdge;

  // This takes in a list of lifetime edges (including for &self borrows)
  // corresponding to data this may borrow from. These should be flat arrays containing
  // references to objects, and this object will hold on to them to keep them alive and
  // maintain borrow validity.
  TimeZone._fromFfi(this._ffi, this._selfEdge) {
    if (_selfEdge.isEmpty) {
      _finalizer.attach(this, _ffi.cast());
    }
  }

  static final _finalizer = ffi.NativeFinalizer(ffi.Native.addressOf(_icu4x_TimeZone_destroy_mv1));

  /// Creates a time zone from an offset string.
  ///
  /// See the [Rust documentation for `try_from_str`](https://docs.rs/icu/latest/icu/timezone/struct.TimeZone.html#method.try_from_str) for more information.
  ///
  /// Throws [TimeZoneUnknownError] on failure.
  factory TimeZone.fromString(String s) {
    final temp = _FinalizedArena();
    final result = _icu4x_TimeZone_from_string_mv1(s._utf8AllocIn(temp.arena));
    if (!result.isOk) {
      throw TimeZoneUnknownError();
    }
    return TimeZone._fromFfi(result.union.ok, []);
  }

  /// Creates a time zone for UTC (Coordinated Universal Time).
  ///
  /// See the [Rust documentation for `utc`](https://docs.rs/icu/latest/icu/timezone/struct.TimeZone.html#method.utc) for more information.
  factory TimeZone.utc() {
    final result = _icu4x_TimeZone_utc_mv1();
    return TimeZone._fromFfi(result, []);
  }

  /// Creates a `TimeZone` from an offset seconds and a BCP-47 string.
  ///
  /// Errors if the string is not a valid BCP-47 time zone ID, or if the offset seconds are out of range.
  ///
  /// See the [Rust documentation for `new`](https://docs.rs/icu/latest/icu/timezone/struct.TimeZone.html#structfield.new) for more information.
  ///
  /// Additional information: [1](https://docs.rs/icu/latest/icu/timezone/struct.UtcOffset.html), [2](https://docs.rs/icu/latest/icu/timezone/struct.TimeZoneBcp47Id.html)
  ///
  /// Throws [TimeZoneUnknownError] on failure.
  factory TimeZone(int offsetSeconds, String id) {
    final temp = _FinalizedArena();
    final result = _icu4x_TimeZone_create_mv1(offsetSeconds, id._utf8AllocIn(temp.arena));
    if (!result.isOk) {
      throw TimeZoneUnknownError();
    }
    return TimeZone._fromFfi(result.union.ok, []);
  }

  /// Crates a `TimeZone` from offset seconds.
  ///
  /// Errors if the offset seconds are out of range.
  ///
  /// See the [Rust documentation for `new_with_offset`](https://docs.rs/icu/latest/icu/timezone/struct.TimeZone.html#method.new_with_offset) for more information.
  ///
  /// See the [Rust documentation for `try_from_offset_seconds`](https://docs.rs/icu/latest/icu/timezone/struct.UtcOffset.html#method.try_from_offset_seconds) for more information.
  ///
  /// Additional information: [1](https://docs.rs/icu/latest/icu/timezone/struct.UtcOffset.html)
  ///
  /// Throws [TimeZoneInvalidOffsetError] on failure.
  factory TimeZone.fromOffsetSeconds(int offsetSeconds) {
    final result = _icu4x_TimeZone_create_from_offset_seconds_mv1(offsetSeconds);
    if (!result.isOk) {
      throw TimeZoneInvalidOffsetError();
    }
    return TimeZone._fromFfi(result.union.ok, []);
  }

  /// Creates a `TimeZone` from a BCP-47 string.
  ///
  /// Errors if the string is not a valid BCP-47 time zone ID.
  ///
  /// See the [Rust documentation for `new_with_bcp47_id`](https://docs.rs/icu/latest/icu/timezone/struct.TimeZone.html#structfield.new_with_bcp47_id) for more information.
  ///
  /// Additional information: [1](https://docs.rs/icu/latest/icu/timezone/struct.TimeZoneBcp47Id.html)
  ///
  /// Throws [TimeZoneInvalidIdError] on failure.
  factory TimeZone.fromBcp47Id(String id) {
    final temp = _FinalizedArena();
    final result = _icu4x_TimeZone_create_from_bcp47_id_mv1(id._utf8AllocIn(temp.arena));
    if (!result.isOk) {
      throw TimeZoneInvalidIdError();
    }
    return TimeZone._fromFfi(result.union.ok, []);
  }

  /// Gets the `offset` field from offset as eighths of an hour.
  ///
  /// See the [Rust documentation for `offset_eighths_of_hour`](https://docs.rs/icu/latest/icu/timezone/struct.UtcOffset.html#method.offset_eighths_of_hour) for more information.
  int? offsetEighthsOfHour() {
    final result = _icu4x_TimeZone_offset_eighths_of_hour_mv1(_ffi);
    if (!result.isOk) {
      return null;
    }
    return result.union.ok;
  }

  /// Returns the value of the `offset` field as offset seconds.
  ///
  /// Returns null if the `offset` field is empty.
  ///
  /// See the [Rust documentation for `offset_seconds`](https://docs.rs/icu/latest/icu/timezone/struct.UtcOffset.html#method.offset_seconds) for more information.
  ///
  /// Additional information: [1](https://docs.rs/icu/latest/icu/timezone/struct.UtcOffset.html)
  int? get offsetSeconds {
    final result = _icu4x_TimeZone_offset_seconds_mv1(_ffi);
    if (!result.isOk) {
      return null;
    }
    return result.union.ok;
  }

  /// Returns whether the `offset` field is positive.
  ///
  /// Returns null if the `offset` field is empty.
  ///
  /// See the [Rust documentation for `is_positive`](https://docs.rs/icu/latest/icu/timezone/struct.UtcOffset.html#method.is_positive) for more information.
  bool? get isOffsetPositive {
    final result = _icu4x_TimeZone_is_offset_positive_mv1(_ffi);
    if (!result.isOk) {
      return null;
    }
    return result.union.ok;
  }

  /// Returns whether the `offset` field is zero.
  ///
  /// Returns null if the `offset` field is empty (which is not the same as zero).
  ///
  /// See the [Rust documentation for `is_zero`](https://docs.rs/icu/latest/icu/timezone/struct.UtcOffset.html#method.is_zero) for more information.
  bool? get isOffsetZero {
    final result = _icu4x_TimeZone_is_offset_zero_mv1(_ffi);
    if (!result.isOk) {
      return null;
    }
    return result.union.ok;
  }

  /// Returns whether the `offset` field has nonzero minutes.
  ///
  /// Returns null if the `offset` field is empty.
  ///
  /// See the [Rust documentation for `has_minutes`](https://docs.rs/icu/latest/icu/timezone/struct.UtcOffset.html#method.has_minutes) for more information.
  bool? get offsetHasMinutes {
    final result = _icu4x_TimeZone_offset_has_minutes_mv1(_ffi);
    if (!result.isOk) {
      return null;
    }
    return result.union.ok;
  }

  /// Returns whether the `offset` field has nonzero seconds.
  ///
  /// Returns null if the `offset` field is empty.
  ///
  /// See the [Rust documentation for `has_seconds`](https://docs.rs/icu/latest/icu/timezone/struct.UtcOffset.html#method.has_seconds) for more information.
  bool? get offsetHasSeconds {
    final result = _icu4x_TimeZone_offset_has_seconds_mv1(_ffi);
    if (!result.isOk) {
      return null;
    }
    return result.union.ok;
  }

  /// Writes the value of the `bcp47_id` field as a string.
  ///
  /// Returns null if the `bcp47_id` field is empty.
  ///
  /// See the [Rust documentation for `bcp47_id`](https://docs.rs/icu/latest/icu/timezone/struct.TimeZone.html#structfield.bcp47_id) for more information.
  ///
  /// Additional information: [1](https://docs.rs/icu/latest/icu/timezone/struct.TimeZoneBcp47Id.html)
  String? get bcp47Id {
    final write = _Write();
    final result = _icu4x_TimeZone_bcp47_id_mv1(_ffi, write._ffi);
    if (!result.isOk) {
      return null;
    }
    return write.finalize();
  }
}

@meta.ResourceIdentifier('icu4x_TimeZone_destroy_mv1')
@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>(isLeaf: true, symbol: 'icu4x_TimeZone_destroy_mv1')
// ignore: non_constant_identifier_names
external void _icu4x_TimeZone_destroy_mv1(ffi.Pointer<ffi.Void> self);

@meta.ResourceIdentifier('icu4x_TimeZone_from_string_mv1')
@ffi.Native<_ResultOpaqueTimeZoneUnknownErrorFfi Function(_SliceUtf8)>(isLeaf: true, symbol: 'icu4x_TimeZone_from_string_mv1')
// ignore: non_constant_identifier_names
external _ResultOpaqueTimeZoneUnknownErrorFfi _icu4x_TimeZone_from_string_mv1(_SliceUtf8 s);

@meta.ResourceIdentifier('icu4x_TimeZone_utc_mv1')
@ffi.Native<ffi.Pointer<ffi.Opaque> Function()>(isLeaf: true, symbol: 'icu4x_TimeZone_utc_mv1')
// ignore: non_constant_identifier_names
external ffi.Pointer<ffi.Opaque> _icu4x_TimeZone_utc_mv1();

@meta.ResourceIdentifier('icu4x_TimeZone_create_mv1')
@ffi.Native<_ResultOpaqueTimeZoneUnknownErrorFfi Function(ffi.Int32, _SliceUtf8)>(isLeaf: true, symbol: 'icu4x_TimeZone_create_mv1')
// ignore: non_constant_identifier_names
external _ResultOpaqueTimeZoneUnknownErrorFfi _icu4x_TimeZone_create_mv1(int offsetSeconds, _SliceUtf8 id);

@meta.ResourceIdentifier('icu4x_TimeZone_create_from_offset_seconds_mv1')
@ffi.Native<_ResultOpaqueTimeZoneInvalidOffsetErrorFfi Function(ffi.Int32)>(isLeaf: true, symbol: 'icu4x_TimeZone_create_from_offset_seconds_mv1')
// ignore: non_constant_identifier_names
external _ResultOpaqueTimeZoneInvalidOffsetErrorFfi _icu4x_TimeZone_create_from_offset_seconds_mv1(int offsetSeconds);

@meta.ResourceIdentifier('icu4x_TimeZone_create_from_bcp47_id_mv1')
@ffi.Native<_ResultOpaqueTimeZoneInvalidIdErrorFfi Function(_SliceUtf8)>(isLeaf: true, symbol: 'icu4x_TimeZone_create_from_bcp47_id_mv1')
// ignore: non_constant_identifier_names
external _ResultOpaqueTimeZoneInvalidIdErrorFfi _icu4x_TimeZone_create_from_bcp47_id_mv1(_SliceUtf8 id);

@meta.ResourceIdentifier('icu4x_TimeZone_offset_eighths_of_hour_mv1')
@ffi.Native<_ResultInt8Void Function(ffi.Pointer<ffi.Opaque>)>(isLeaf: true, symbol: 'icu4x_TimeZone_offset_eighths_of_hour_mv1')
// ignore: non_constant_identifier_names
external _ResultInt8Void _icu4x_TimeZone_offset_eighths_of_hour_mv1(ffi.Pointer<ffi.Opaque> self);

@meta.ResourceIdentifier('icu4x_TimeZone_offset_seconds_mv1')
@ffi.Native<_ResultInt32Void Function(ffi.Pointer<ffi.Opaque>)>(isLeaf: true, symbol: 'icu4x_TimeZone_offset_seconds_mv1')
// ignore: non_constant_identifier_names
external _ResultInt32Void _icu4x_TimeZone_offset_seconds_mv1(ffi.Pointer<ffi.Opaque> self);

@meta.ResourceIdentifier('icu4x_TimeZone_is_offset_positive_mv1')
@ffi.Native<_ResultBoolVoid Function(ffi.Pointer<ffi.Opaque>)>(isLeaf: true, symbol: 'icu4x_TimeZone_is_offset_positive_mv1')
// ignore: non_constant_identifier_names
external _ResultBoolVoid _icu4x_TimeZone_is_offset_positive_mv1(ffi.Pointer<ffi.Opaque> self);

@meta.ResourceIdentifier('icu4x_TimeZone_is_offset_zero_mv1')
@ffi.Native<_ResultBoolVoid Function(ffi.Pointer<ffi.Opaque>)>(isLeaf: true, symbol: 'icu4x_TimeZone_is_offset_zero_mv1')
// ignore: non_constant_identifier_names
external _ResultBoolVoid _icu4x_TimeZone_is_offset_zero_mv1(ffi.Pointer<ffi.Opaque> self);

@meta.ResourceIdentifier('icu4x_TimeZone_offset_has_minutes_mv1')
@ffi.Native<_ResultBoolVoid Function(ffi.Pointer<ffi.Opaque>)>(isLeaf: true, symbol: 'icu4x_TimeZone_offset_has_minutes_mv1')
// ignore: non_constant_identifier_names
external _ResultBoolVoid _icu4x_TimeZone_offset_has_minutes_mv1(ffi.Pointer<ffi.Opaque> self);

@meta.ResourceIdentifier('icu4x_TimeZone_offset_has_seconds_mv1')
@ffi.Native<_ResultBoolVoid Function(ffi.Pointer<ffi.Opaque>)>(isLeaf: true, symbol: 'icu4x_TimeZone_offset_has_seconds_mv1')
// ignore: non_constant_identifier_names
external _ResultBoolVoid _icu4x_TimeZone_offset_has_seconds_mv1(ffi.Pointer<ffi.Opaque> self);

@meta.ResourceIdentifier('icu4x_TimeZone_bcp47_id_mv1')
@ffi.Native<_ResultVoidVoid Function(ffi.Pointer<ffi.Opaque>, ffi.Pointer<ffi.Opaque>)>(isLeaf: true, symbol: 'icu4x_TimeZone_bcp47_id_mv1')
// ignore: non_constant_identifier_names
external _ResultVoidVoid _icu4x_TimeZone_bcp47_id_mv1(ffi.Pointer<ffi.Opaque> self, ffi.Pointer<ffi.Opaque> write);
