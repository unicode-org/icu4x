// generated by diplomat-tool
// dart format off

part of 'lib.g.dart';

final class _DateFieldsFfi extends ffi.Struct {
  external _ResultSliceUtf8Void era;
  external _ResultInt32Void eraYear;
  external _ResultInt32Void extendedYear;
  external _ResultSliceUtf8Void monthCode;
  external _ResultUint8Void ordinalMonth;
  external _ResultUint8Void day;
}

/// See the [Rust documentation for `DateFields`](https://docs.rs/icu/2.0.0/icu/calendar/types/struct.DateFields.html) for more information.
final class DateFields {
  String? era;
  int? eraYear;
  int? extendedYear;
  String? monthCode;
  int? ordinalMonth;
  int? day;

  DateFields({this.era, this.eraYear, this.extendedYear, this.monthCode, this.ordinalMonth, this.day});

  // ignore: unused_element
  DateFields._fromFfi(_DateFieldsFfi ffi, core.List<Object> aEdges) :
    era = ffi.era.isOk ? ffi.era.union.ok._toDart(aEdges) : null,
    eraYear = ffi.eraYear.isOk ? ffi.eraYear.union.ok : null,
    extendedYear = ffi.extendedYear.isOk ? ffi.extendedYear.union.ok : null,
    monthCode = ffi.monthCode.isOk ? ffi.monthCode.union.ok._toDart(aEdges) : null,
    ordinalMonth = ffi.ordinalMonth.isOk ? ffi.ordinalMonth.union.ok : null,
    day = ffi.day.isOk ? ffi.day.union.ok : null;

  // If this struct contains any slices, their lifetime-edge-relevant objects (typically _FinalizedArenas) will only
  // be constructed here, and can be appended to any relevant lifetime arrays here. <lifetime>AppendArray accepts a list
  // of arrays for each lifetime to do so. It accepts multiple lists per lifetime in case the caller needs to tie a lifetime to multiple
  // output arrays. Null is equivalent to an empty list: this lifetime is not being borrowed from.
  // ignore: unused_element
  _DateFieldsFfi _toFfi(ffi.Allocator temp, {core.List<core.List<Object>> aAppendArray = const []}) {
    final struct = ffi.Struct.create<_DateFieldsFfi>();
    String? era = this.era;
    struct.era = era != null ? _ResultSliceUtf8Void.ok(era._utf8AllocIn(aAppendArray.isNotEmpty ? _FinalizedArena.withLifetime(aAppendArray).arena : temp)) : _ResultSliceUtf8Void.err();
    int? eraYear = this.eraYear;
    struct.eraYear = eraYear != null ? _ResultInt32Void.ok(eraYear) : _ResultInt32Void.err();
    int? extendedYear = this.extendedYear;
    struct.extendedYear = extendedYear != null ? _ResultInt32Void.ok(extendedYear) : _ResultInt32Void.err();
    String? monthCode = this.monthCode;
    struct.monthCode = monthCode != null ? _ResultSliceUtf8Void.ok(monthCode._utf8AllocIn(aAppendArray.isNotEmpty ? _FinalizedArena.withLifetime(aAppendArray).arena : temp)) : _ResultSliceUtf8Void.err();
    int? ordinalMonth = this.ordinalMonth;
    struct.ordinalMonth = ordinalMonth != null ? _ResultUint8Void.ok(ordinalMonth) : _ResultUint8Void.err();
    int? day = this.day;
    struct.day = day != null ? _ResultUint8Void.ok(day) : _ResultUint8Void.err();
    return struct;
  }


  @override
  bool operator ==(Object other) =>
      other is DateFields &&
      other.era == era &&
      other.eraYear == eraYear &&
      other.extendedYear == extendedYear &&
      other.monthCode == monthCode &&
      other.ordinalMonth == ordinalMonth &&
      other.day == day;

  @override
  int get hashCode => Object.hashAll([
        era,
        eraYear,
        extendedYear,
        monthCode,
        ordinalMonth,
        day,
      ]);

  // Return all fields corresponding to lifetime `'a`
  // without handling lifetime dependencies (this is the job of the caller)
  // This is all fields that may be borrowed from if borrowing `'a`,
  // assuming that there are no `'other: a`. bounds. In case of such bounds,
  // the caller should take care to also call _fieldsForLifetimeOther
  // ignore: unused_element
  core.List<Object> get _fieldsForLifetimeA => [if (era != null) era!, if (monthCode != null) monthCode!];
}

// dart format on
