// generated by diplomat-tool
import wasm from "./diplomat-wasm.mjs";
import * as diplomatRuntime from "./diplomat-runtime.mjs";



/**
 * See the [Rust documentation for `DateFields`](https://docs.rs/icu/2.0.0/icu/calendar/types/struct.DateFields.html) for more information.
 */
export class DateFields {
    #era;
    get era() {
        return this.#era;
    }
    set era(value){
        this.#era = value;
    }
    #eraYear;
    get eraYear() {
        return this.#eraYear;
    }
    set eraYear(value){
        this.#eraYear = value;
    }
    #extendedYear;
    get extendedYear() {
        return this.#extendedYear;
    }
    set extendedYear(value){
        this.#extendedYear = value;
    }
    #monthCode;
    get monthCode() {
        return this.#monthCode;
    }
    set monthCode(value){
        this.#monthCode = value;
    }
    #ordinalMonth;
    get ordinalMonth() {
        return this.#ordinalMonth;
    }
    set ordinalMonth(value){
        this.#ordinalMonth = value;
    }
    #day;
    get day() {
        return this.#day;
    }
    set day(value){
        this.#day = value;
    }
    /** @internal */
    static fromFields(structObj) {
        return new DateFields(structObj);
    }

    #internalConstructor(structObj) {
        if (typeof structObj !== "object") {
            throw new Error("DateFields's constructor takes an object of DateFields's fields.");
        }

        if ("era" in structObj) {
            this.#era = structObj.era;
        } else {
            this.#era = null;
        }

        if ("eraYear" in structObj) {
            this.#eraYear = structObj.eraYear;
        } else {
            this.#eraYear = null;
        }

        if ("extendedYear" in structObj) {
            this.#extendedYear = structObj.extendedYear;
        } else {
            this.#extendedYear = null;
        }

        if ("monthCode" in structObj) {
            this.#monthCode = structObj.monthCode;
        } else {
            this.#monthCode = null;
        }

        if ("ordinalMonth" in structObj) {
            this.#ordinalMonth = structObj.ordinalMonth;
        } else {
            this.#ordinalMonth = null;
        }

        if ("day" in structObj) {
            this.#day = structObj.day;
        } else {
            this.#day = null;
        }

        return this;
    }

    // Return this struct in FFI function friendly format.
    // Returns an array that can be expanded with spread syntax (...)// If this struct contains any slices, their lifetime-edge-relevant information will be
    // set up here, and can be appended to any relevant lifetime arrays here. <lifetime>AppendArray accepts a list
    // of arrays for each lifetime to do so. It accepts multiple lists per lifetime in case the caller needs to tie a lifetime to multiple
    // output arrays. Null is equivalent to an empty list: this lifetime is not being borrowed from.
    _intoFFI(
        functionCleanupArena,
        appendArrayMap
    ) {
        let buffer = diplomatRuntime.DiplomatBuf.struct(wasm, 44, 4);

        this._writeToArrayBuffer(wasm.memory.buffer, buffer.ptr, functionCleanupArena, appendArrayMap);

        functionCleanupArena.alloc(buffer);

        return buffer.ptr;
    }

    static _fromSuppliedValue(internalConstructor, obj) {
        if (internalConstructor !== diplomatRuntime.internalConstructor) {
            throw new Error("_fromSuppliedValue cannot be called externally.");
        }

        if (obj instanceof DateFields) {
            return obj;
        }

        return DateFields.fromFields(obj);
    }

    _writeToArrayBuffer(
        arrayBuffer,
        offset,
        functionCleanupArena,
        appendArrayMap
    ) {
        diplomatRuntime.writeOptionToArrayBuffer(arrayBuffer, offset + 0, this.#era, 8, 4, (arrayBuffer, offset, jsValue) => diplomatRuntime.CleanupArena.maybeCreateWith(functionCleanupArena, ...appendArrayMap['aAppendArray']).alloc(diplomatRuntime.DiplomatBuf.str8(wasm, jsValue)).writePtrLenToArrayBuffer(arrayBuffer, offset + 0));
        diplomatRuntime.writeOptionToArrayBuffer(arrayBuffer, offset + 12, this.#eraYear, 4, 4, (arrayBuffer, offset, jsValue) => diplomatRuntime.writeToArrayBuffer(arrayBuffer, offset + 0, jsValue, Int32Array));
        diplomatRuntime.writeOptionToArrayBuffer(arrayBuffer, offset + 20, this.#extendedYear, 4, 4, (arrayBuffer, offset, jsValue) => diplomatRuntime.writeToArrayBuffer(arrayBuffer, offset + 0, jsValue, Int32Array));
        diplomatRuntime.writeOptionToArrayBuffer(arrayBuffer, offset + 28, this.#monthCode, 8, 4, (arrayBuffer, offset, jsValue) => diplomatRuntime.CleanupArena.maybeCreateWith(functionCleanupArena, ...appendArrayMap['aAppendArray']).alloc(diplomatRuntime.DiplomatBuf.str8(wasm, jsValue)).writePtrLenToArrayBuffer(arrayBuffer, offset + 0));
        diplomatRuntime.writeOptionToArrayBuffer(arrayBuffer, offset + 40, this.#ordinalMonth, 1, 1, (arrayBuffer, offset, jsValue) => diplomatRuntime.writeToArrayBuffer(arrayBuffer, offset + 0, jsValue, Uint8Array));
        diplomatRuntime.writeOptionToArrayBuffer(arrayBuffer, offset + 42, this.#day, 1, 1, (arrayBuffer, offset, jsValue) => diplomatRuntime.writeToArrayBuffer(arrayBuffer, offset + 0, jsValue, Uint8Array));
    }

    static _fromFFI(internalConstructor, ptr, aEdges) {
        if (internalConstructor !== diplomatRuntime.internalConstructor) {
            throw new Error("DateFields._fromFFI is not meant to be called externally. Please use the default constructor.");
        }
        let structObj = {};
        const eraDeref = ptr;
        structObj.era = diplomatRuntime.readOption(wasm, eraDeref, 8, (wasm, offset) => { const deref = offset; return new diplomatRuntime.DiplomatSliceStr(wasm, deref,  "string8", aEdges).getValue() });
        const eraYearDeref = ptr + 12;
        structObj.eraYear = diplomatRuntime.readOption(wasm, eraYearDeref, 4, (wasm, offset) => { const deref = (new Int32Array(wasm.memory.buffer, offset, 1))[0]; return deref });
        const extendedYearDeref = ptr + 20;
        structObj.extendedYear = diplomatRuntime.readOption(wasm, extendedYearDeref, 4, (wasm, offset) => { const deref = (new Int32Array(wasm.memory.buffer, offset, 1))[0]; return deref });
        const monthCodeDeref = ptr + 28;
        structObj.monthCode = diplomatRuntime.readOption(wasm, monthCodeDeref, 8, (wasm, offset) => { const deref = offset; return new diplomatRuntime.DiplomatSliceStr(wasm, deref,  "string8", aEdges).getValue() });
        const ordinalMonthDeref = ptr + 40;
        structObj.ordinalMonth = diplomatRuntime.readOption(wasm, ordinalMonthDeref, 1, (wasm, offset) => { const deref = (new Uint8Array(wasm.memory.buffer, offset, 1))[0]; return deref });
        const dayDeref = ptr + 42;
        structObj.day = diplomatRuntime.readOption(wasm, dayDeref, 1, (wasm, offset) => { const deref = (new Uint8Array(wasm.memory.buffer, offset, 1))[0]; return deref });

        return new DateFields(structObj);
    }

    // Return all fields corresponding to lifetime `'a`
    // without handling lifetime dependencies (this is the job of the caller)
    // This is all fields that may be borrowed from if borrowing `'a`,
    // assuming that there are no `'other: a`. bounds. In case of such bounds,
    // the caller should take care to also call _fieldsForLifetimeOther
    get _fieldsForLifetimeA() {
        return [this.#era, this.#monthCode];
    };


    constructor(structObj) {
        return this.#internalConstructor(...arguments)
    }
}