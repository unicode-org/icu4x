// This file is part of ICU4X. For terms of use, please see the file
// called LICENSE at the top level of the ICU4X source tree
// (online at: https://github.com/unicode-org/icu4x/blob/main/LICENSE ).

use databake::Bake;
use icu_casemap::greek_to_me::{self, GreekPrecomposedLetterData};
use icu_casemap::CaseMapper;
use icu_codepointtrie_builder::{CodePointTrieBuilder, CodePointTrieBuilderData};
use icu_collections::codepointtrie::{CodePointTrie, TrieType};
use icu_locid::langid;
use icu_normalizer::DecomposingNormalizer;
use icu_properties::{maps, GeneralCategoryGroup, Script};
use std::io::Write;
use std::path::PathBuf;
use std::process::{Command, Stdio};
use std::{env, fs, str};

fn main() {
    let size = u32::from(char::MAX);
    let mut vec = Vec::with_capacity(size as usize);
    let mut encode_scratch = [0; 4];

    let decomposer = DecomposingNormalizer::new_nfd();
    let script = maps::script();
    let gc = maps::general_category();
    let cm = CaseMapper::new();
    let und = langid!("und");

    for ch in 0..=size {
        let mut data = GreekPrecomposedLetterData::default();
        if let Ok(ch) = char::try_from(ch) {
            // Check for [:Grek:] and [:L:]
            if script.get(ch) != Script::Greek || !GeneralCategoryGroup::Letter.contains(gc.get(ch))
            {
                vec.push(data);
                continue;
            }

            let s = ch.encode_utf8(&mut encode_scratch);
            let nfd = decomposer.normalize_utf8(s.as_bytes());

            // accented: [:toNFD=/[\u0300\u0301\u0342\u0302\u0303\u0311]/:]&[:Grek:]&[:L:] (from the JSPs: toNFD is an extension).

            for nfd_ch in nfd.chars() {
                match nfd_ch {
                    greek_to_me::accent_marks!() => {
                        data.accented = true;
                    }
                    // dialytika: [:toNFD=/[\u0308]/:]&[:Grek:]&[:L:] (from the JSPs: toNFD is an extension).
                    greek_to_me::DIALYTIKA => {
                        data.dialytika = true;
                    }
                    // precomposed_yprog: [:toNFD=/[\u0345]/:]&[:Grek:]&[:L:] (from the JSPs: toNFD is an extension).
                    greek_to_me::YPOGEGRAMMENI => {
                        data.ypogegrammeni = true;
                    }
                    // Ignore all small letters
                    '\u{1D00}'..='\u{1DBF}' | '\u{AB65}' => (),
                    // caps: [[:Grek:]&[:L:]-[\u1D00-\u1DBF\uAB65]] . NFD, remove non-letters, uppercase
                    letter if GeneralCategoryGroup::Letter.contains(gc.get(letter)) => {
                        if data.uppercase.is_some() {
                            panic!("Found multiple letters within decomposition of {ch}");
                        }
                        let letter = letter.encode_utf8(&mut encode_scratch);
                        let uppercased = cm.uppercase_to_string(&letter, &und);
                        let mut iter = uppercased.chars();
                        let uppercased = iter.next().unwrap();
                        assert!(
                            iter.next().is_none(),
                            "{letter} Should uppercase to a single letter char, instead uppercased to {uppercased:?}"
                        );
                        data.uppercase = Some(uppercased);
                    }
                    _ => (),
                }
            }
        }

        vec.push(data)
    }

    let data = CodePointTrieBuilderData::ValuesByCodePoint(&vec);
    let trie: CodePointTrie<GreekPrecomposedLetterData> = CodePointTrieBuilder {
        data,
        default_value: GreekPrecomposedLetterData::default(),
        error_value: GreekPrecomposedLetterData::default(),
        trie_type: TrieType::Small,
    }
    .build();

    let output = format!(
        r#"// This file is part of ICU4X. For terms of use, please see the file
// called LICENSE at the top level of the ICU4X source tree
// (online at: https://github.com/unicode-org/icu4x/blob/main/LICENSE ).

// This file is generated by running `cargo test --test gen_greek_to_me --features compiled_data,datagen
//
// Do not edit manually

use super::GreekPrecomposedLetterData;
use icu_collections::codepointtrie::CodePointTrie;

pub(crate) const GREEK_DATA_TRIE: CodePointTrie<'static, GreekPrecomposedLetterData> = {};
"#,
        trie.bake(&Default::default())
    );

    let mut rustfmt = Command::new("rustfmt")
        .arg("--config")
        .arg("newline_style=unix")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .expect("spawn failed");
    let mut rustfmt_stdin = rustfmt.stdin.take().unwrap();
    write!(rustfmt_stdin, "{output}").expect("write failed");

    drop(rustfmt_stdin); // EOF

    let output = rustfmt
        .wait_with_output()
        .expect("execution of rustfmt failed");
    if !output.status.success() {
        let stderr = String::from_utf8(output.stderr).expect("rustfmt output not utf-8");
        panic!("rustfmt failed: {stderr}");
    }
    let output = String::from_utf8(output.stdout).expect("rustfmt output not utf-8");

    let local = env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR set");
    let mut local = PathBuf::from(local);
    local.push("src");
    local.push("greek_to_me");
    local.push("data.rs");

    let local = fs::read(local).expect("src/greek_to_me/data.rs should exist");
    let local = str::from_utf8(&local).expect("src/greek_to_me/data.rs should be UTF-8");

    if local.trim() != output.trim() {
        println!(
            r#"Please copy the following file to src/greek_to_me/data.rs:
========================================================
{output}
========================================================"#
        );
        panic!("Found mismatch between generated Greek specialcasing data and checked-in data. Please check in the updated file shown above.");
    }
}
