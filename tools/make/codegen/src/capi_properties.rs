// This file is part of ICU4X. For terms of use, please see the file
// called LICENSE at the top level of the ICU4X source tree
// (online at: https://github.com/unicode-org/icu4x/blob/main/LICENSE ).

use std::collections::BTreeSet;
use std::{fs::File, path::PathBuf};

use askama::Template;
use icu::properties::props::*;

pub(crate) const GENERATED_BY: &str = std::concat!("@generated by ", std::file!());

#[derive(Template)]
#[template(path = "properties_enums.rs.jinja")]
struct PropertiesEnums<'a> {
    props: &'a [Prop],
}

#[derive(Template)]
#[template(path = "properties_maps.rs.jinja")]
struct PropertiesMaps<'a> {
    props: &'a [Prop],
}

#[derive(Template)]
#[template(path = "properties_names.rs.jinja")]
struct PropertiesNames<'a> {
    props: &'a [Prop],
}

#[derive(Template)]
#[template(path = "properties_sets.rs.jinja")]
struct PropertiesSets<'a> {
    binary_props: &'a [BinaryProp],
}

struct Prop {
    name: String,
    is_open: bool,
    int_type: &'static str,
    variants: Vec<(String, u32)>,
}

impl Prop {
    fn kind(&self) -> &'static str {
        if self.is_open {
            "Struct"
        } else {
            "Enum"
        }
    }

    fn variant_kind(&self) -> &'static str {
        if self.is_open {
            "AssociatedConstantInStruct"
        } else {
            "EnumVariant"
        }
    }

    fn is_default(&self, discriminant: u32) -> bool {
        if let Some(&(_, d)) = self
            .variants
            .iter()
            .find(|(n, _)| n == "Unknown" || n == "Unassigned")
        {
            discriminant == d
        } else {
            discriminant == 0
        }
    }

    fn snake_case(&self) -> String {
        use heck::ToSnakeCase;
        self.name.to_snake_case()
    }

    fn map_type(&self) -> &'static str {
        if self.int_type == "u8" {
            "CodePointMapData8"
        } else {
            "CodePointMapData16"
        }
    }
}

struct BinaryProp {
    property_name: String,
    struct_name: String,
}

impl BinaryProp {
    fn func_name(&self) -> String {
        use heck::ToSnakeCase;
        self.property_name.to_snake_case()
    }
}

pub fn main() {
    let mut path_buf = PathBuf::new();
    path_buf.push(env!("CARGO_MANIFEST_DIR"));
    path_buf.push("../../../ffi/capi/src");

    fn variants(values: &[impl NamedEnumeratedProperty]) -> Vec<(String, u32)> {
        values
            .iter()
            .map(|v| {
                (
                    v.long_name()
                        .replace('_', "")
                        .replace("Ethiopic", "Ethiopian")
                        .replace("Aran", "Nastaliq")
                        .replace("LVSyllable", "LeadingVowelSyllable")
                        .replace("LVTSyllable", "LeadingVowelTrailingSyllable"),
                    v.to_u32(),
                )
            })
            .collect()
    }

    let props = &[
        Prop {
            name: "BidiClass".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(BidiClass::ALL_VALUES),
        },
        Prop {
            name: "NumericType".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(NumericType::ALL_VALUES),
        },
        Prop {
            name: "Script".into(),
            is_open: true,
            int_type: "u16",
            #[allow(deprecated)]
            variants: variants(Script::ALL_VALUES)
                .into_iter()
                .chain([("Chisoi".into(), 254)])
                .collect::<BTreeSet<_>>()
                .into_iter()
                .collect(),
        },
        Prop {
            name: "HangulSyllableType".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(HangulSyllableType::ALL_VALUES),
        },
        Prop {
            name: "EastAsianWidth".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(EastAsianWidth::ALL_VALUES),
        },
        Prop {
            name: "LineBreak".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(LineBreak::ALL_VALUES),
        },
        Prop {
            name: "GraphemeClusterBreak".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(GraphemeClusterBreak::ALL_VALUES),
        },
        Prop {
            name: "WordBreak".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(WordBreak::ALL_VALUES),
        },
        Prop {
            name: "SentenceBreak".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(SentenceBreak::ALL_VALUES),
        },
        Prop {
            name: "CanonicalCombiningClass".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(CanonicalCombiningClass::ALL_VALUES),
        },
        Prop {
            name: "IndicSyllabicCategory".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(IndicSyllabicCategory::ALL_VALUES),
        },
        Prop {
            name: "IndicConjunctBreak".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(IndicConjunctBreak::ALL_VALUES),
        },
        Prop {
            name: "JoiningGroup".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(JoiningGroup::ALL_VALUES),
        },
        Prop {
            name: "JoiningType".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(JoiningType::ALL_VALUES),
        },
        Prop {
            name: "GeneralCategory".into(),
            is_open: false,
            int_type: "u8",
            variants: variants(GeneralCategory::ALL_VALUES),
        },
        Prop {
            name: "VerticalOrientation".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(VerticalOrientation::ALL_VALUES),
        },
    ];

    {
        let mut path_buf = path_buf.clone();
        path_buf.push("properties_enums.rs");
        let mut file = File::create(&path_buf).unwrap();
        use std::io::Write;
        writeln!(&mut file, "{}", PropertiesEnums { props }).unwrap();
    }

    {
        let mut path_buf = path_buf.clone();
        path_buf.push("properties_maps.rs");
        let mut file = File::create(&path_buf).unwrap();
        use std::io::Write;
        writeln!(&mut file, "{}", PropertiesMaps { props }).unwrap();
    }

    {
        let mut path_buf = path_buf.clone();
        path_buf.push("properties_names.rs");
        let mut file = File::create(&path_buf).unwrap();
        use std::io::Write;
        writeln!(&mut file, "{}", PropertiesNames { props }).unwrap();
    }

    let binary_props = &[
        BinaryProp { property_name: "ASCII_Hex_Digit".into(), struct_name: "AsciiHexDigit".into() },
        BinaryProp { property_name: "alnum".into(), struct_name: "Alnum".into() },
        BinaryProp { property_name: "Alphabetic".into(), struct_name: "Alphabetic".into() },
        BinaryProp { property_name: "Bidi_Control".into(), struct_name: "BidiControl".into() },
        BinaryProp { property_name: "Bidi_Mirrored".into(), struct_name: "BidiMirrored".into() },
        BinaryProp { property_name: "blank".into(), struct_name: "Blank".into() },
        BinaryProp { property_name: "Cased".into(), struct_name: "Cased".into() },
        BinaryProp { property_name: "Case_Ignorable".into(), struct_name: "CaseIgnorable".into() },
        BinaryProp { property_name: "Case_Sensitive".into(), struct_name: "CaseSensitive".into() },
        BinaryProp { property_name: "Changes_When_Casefolded".into(), struct_name: "ChangesWhenCasefolded".into() },
        BinaryProp { property_name: "Changes_When_Casemapped".into(), struct_name: "ChangesWhenCasemapped".into() },
        BinaryProp { property_name: "Changes_When_Lowercased".into(), struct_name: "ChangesWhenLowercased".into() },
        BinaryProp { property_name: "Changes_When_NFKC_Casefolded".into(), struct_name: "ChangesWhenNfkcCasefolded".into() },
        BinaryProp { property_name: "Changes_When_Titlecased".into(), struct_name: "ChangesWhenTitlecased".into() },
        BinaryProp { property_name: "Changes_When_Uppercased".into(), struct_name: "ChangesWhenUppercased".into() },
        BinaryProp { property_name: "Dash".into(), struct_name: "Dash".into() },
        BinaryProp { property_name: "Default_Ignorable_Code_Point".into(), struct_name: "DefaultIgnorableCodePoint".into() },
        BinaryProp { property_name: "Deprecated".into(), struct_name: "Deprecated".into() },
        BinaryProp { property_name: "Diacritic".into(), struct_name: "Diacritic".into() },
        BinaryProp { property_name: "Emoji".into(), struct_name: "Emoji".into() },
        BinaryProp { property_name: "Emoji_Component".into(), struct_name: "EmojiComponent".into() },
        BinaryProp { property_name: "Emoji_Modifier".into(), struct_name: "EmojiModifier".into() },
        BinaryProp { property_name: "Emoji_Modifier_Base".into(), struct_name: "EmojiModifierBase".into() },
        BinaryProp { property_name: "Emoji_Presentation".into(), struct_name: "EmojiPresentation".into() },
        BinaryProp { property_name: "Extender".into(), struct_name: "Extender".into() },
        BinaryProp { property_name: "Extended_Pictographic".into(), struct_name: "ExtendedPictographic".into() },
        BinaryProp { property_name: "Full_Composition_Exclusion".into(), struct_name: "FullCompositionExclusion".into() },
        BinaryProp { property_name: "graph".into(), struct_name: "Graph".into() },
        BinaryProp { property_name: "Grapheme_Base".into(), struct_name: "GraphemeBase".into() },
        BinaryProp { property_name: "Grapheme_Extend".into(), struct_name: "GraphemeExtend".into() },
        BinaryProp { property_name: "Grapheme_Link".into(), struct_name: "GraphemeLink".into() },
        BinaryProp { property_name: "Hex_Digit".into(), struct_name: "HexDigit".into() },
        BinaryProp { property_name: "Hyphen".into(), struct_name: "Hyphen".into() },
        BinaryProp { property_name: "ID_Compat_Math_Continue".into(), struct_name: "IdCompatMathContinue".into() },
        BinaryProp { property_name: "ID_Compat_Math_Start".into(), struct_name: "IdCompatMathStart".into() },
        BinaryProp { property_name: "ID_Continue".into(), struct_name: "IdContinue".into() },
        BinaryProp { property_name: "ID_Start".into(), struct_name: "IdStart".into() },
        BinaryProp { property_name: "Ideographic".into(), struct_name: "Ideographic".into() },
        BinaryProp { property_name: "IDS_Binary_Operator".into(), struct_name: "IdsBinaryOperator".into() },
        BinaryProp { property_name: "IDS_Trinary_Operator".into(), struct_name: "IdsTrinaryOperator".into() },
        BinaryProp { property_name: "IDS_Unary_Operator".into(), struct_name: "IdsUnaryOperator".into() },
        BinaryProp { property_name: "Join_Control".into(), struct_name: "JoinControl".into() },
        BinaryProp { property_name: "Logical_Order_Exception".into(), struct_name: "LogicalOrderException".into() },
        BinaryProp { property_name: "Lowercase".into(), struct_name: "Lowercase".into() },
        BinaryProp { property_name: "Math".into(), struct_name: "Math".into() },
        BinaryProp { property_name: "Modifier_Combining_Mark".into(), struct_name: "ModifierCombiningMark".into() },
        BinaryProp { property_name: "Noncharacter_Code_Point".into(), struct_name: "NoncharacterCodePoint".into() },
        BinaryProp { property_name: "NFC_Inert".into(), struct_name: "NfcInert".into() },
        BinaryProp { property_name: "NFD_Inert".into(), struct_name: "NfdInert".into() },
        BinaryProp { property_name: "NFKC_Inert".into(), struct_name: "NfkcInert".into() },
        BinaryProp { property_name: "NFKD_Inert".into(), struct_name: "NfkdInert".into() },
        BinaryProp { property_name: "Pattern_Syntax".into(), struct_name: "PatternSyntax".into() },
        BinaryProp { property_name: "Pattern_White_Space".into(), struct_name: "PatternWhiteSpace".into() },
        BinaryProp { property_name: "Prepended_Concatenation_Mark".into(), struct_name: "PrependedConcatenationMark".into() },
        BinaryProp { property_name: "print".into(), struct_name: "Print".into() },
        BinaryProp { property_name: "Quotation_Mark".into(), struct_name: "QuotationMark".into() },
        BinaryProp { property_name: "Radical".into(), struct_name: "Radical".into() },
        BinaryProp { property_name: "Regional_Indicator".into(), struct_name: "RegionalIndicator".into() },
        BinaryProp { property_name: "Segment_Starter".into(), struct_name: "SegmentStarter".into() },
        BinaryProp { property_name: "Sentence_Terminal".into(), struct_name: "SentenceTerminal".into() },
        BinaryProp { property_name: "Soft_Dotted".into(), struct_name: "SoftDotted".into() },
        BinaryProp { property_name: "Terminal_Punctuation".into(), struct_name: "TerminalPunctuation".into() },
        BinaryProp { property_name: "Unified_Ideograph".into(), struct_name: "UnifiedIdeograph".into() },
        BinaryProp { property_name: "Uppercase".into(), struct_name: "Uppercase".into() },
        BinaryProp { property_name: "Variation_Selector".into(), struct_name: "VariationSelector".into() },
        BinaryProp { property_name: "White_Space".into(), struct_name: "WhiteSpace".into() },
        BinaryProp { property_name: "xdigit".into(), struct_name: "Xdigit".into() },
        BinaryProp { property_name: "XID_Continue".into(), struct_name: "XidContinue".into() },
        BinaryProp { property_name: "XID_Start".into(), struct_name: "XidStart".into() },
    ];

    {
        let mut path_buf = path_buf.clone();
        path_buf.push("properties_sets.rs");
        let mut file = File::create(&path_buf).unwrap();
        use std::io::Write;
        writeln!(&mut file, "{}", PropertiesSets { binary_props }).unwrap();
    }
}
