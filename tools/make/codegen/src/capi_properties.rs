// This file is part of ICU4X. For terms of use, please see the file
// called LICENSE at the top level of the ICU4X source tree
// (online at: https://github.com/unicode-org/icu4x/blob/main/LICENSE ).

use std::collections::BTreeSet;
use std::{fs::File, path::PathBuf};

use askama::Template;
use icu::properties::props::*;

const GENERATED_BY: &str = "@generated by tools/make/codegen/src/capi_properties.rs";

#[derive(Template)]
#[template(path = "properties_enums.rs.jinja")]
struct PropertiesEnums<'a> {
    props: &'a [Prop],
}

#[derive(Template)]
#[template(path = "properties_maps.rs.jinja")]
struct PropertiesMaps<'a> {
    props: &'a [Prop],
}

#[derive(Template)]
#[template(path = "properties_names.rs.jinja")]
struct PropertiesNames<'a> {
    props: &'a [Prop],
}

#[derive(Template)]
#[template(path = "properties_sets.rs.jinja")]
struct PropertiesSets<'a> {
    binary_props: &'a [BinaryProp],
}

struct Prop {
    name: String,
    is_open: bool,
    int_type: &'static str,
    variants: Vec<(String, u32)>,
}

impl Prop {
    fn kind(&self) -> &'static str {
        if self.is_open {
            "Struct"
        } else {
            "Enum"
        }
    }

    fn variant_kind(&self) -> &'static str {
        if self.is_open {
            "AssociatedConstantInStruct"
        } else {
            "EnumVariant"
        }
    }

    fn is_default(&self, discriminant: u32) -> bool {
        if let Some(&(_, d)) = self
            .variants
            .iter()
            .find(|(n, _)| n == "Unknown" || n == "Unassigned")
        {
            discriminant == d
        } else {
            discriminant == 0
        }
    }

    fn snake_case(&self) -> String {
        use heck::ToSnakeCase;
        self.name.to_snake_case()
    }

    fn map_type(&self) -> &'static str {
        if self.int_type == "u8" {
            "CodePointMapData8"
        } else {
            "CodePointMapData16"
        }
    }
}

struct BinaryProp {
    property_name: &'static [u8],
    struct_name: &'static str,
}

impl BinaryProp {
    fn property_name(&self) -> &str {
        std::str::from_utf8(self.property_name).unwrap()
    }

    fn func_name(&self) -> String {
        use heck::ToSnakeCase;
        self.property_name().to_snake_case()
    }

    /// Returns the property name as it appears in doc comments (struct name with underscores)
    fn doc_name(&self) -> String {
        self.property_name().to_string()
    }
}

pub fn main() {
    let mut path_buf = PathBuf::new();
    path_buf.push(env!("CARGO_MANIFEST_DIR"));
    path_buf.push("../../../ffi/capi/src");

    fn variants(values: &[impl NamedEnumeratedProperty]) -> Vec<(String, u32)> {
        values
            .iter()
            .map(|v| {
                (
                    v.long_name()
                        .replace('_', "")
                        .replace("Ethiopic", "Ethiopian")
                        .replace("Aran", "Nastaliq")
                        .replace("LVSyllable", "LeadingVowelSyllable")
                        .replace("LVTSyllable", "LeadingVowelTrailingSyllable"),
                    v.to_u32(),
                )
            })
            .collect()
    }

    let props = &[
        Prop {
            name: "BidiClass".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(BidiClass::ALL_VALUES),
        },
        Prop {
            name: "NumericType".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(NumericType::ALL_VALUES),
        },
        Prop {
            name: "Script".into(),
            is_open: true,
            int_type: "u16",
            #[allow(deprecated)]
            variants: variants(Script::ALL_VALUES)
                .into_iter()
                .chain([("Chisoi".into(), 254)])
                .collect::<BTreeSet<_>>()
                .into_iter()
                .collect(),
        },
        Prop {
            name: "HangulSyllableType".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(HangulSyllableType::ALL_VALUES),
        },
        Prop {
            name: "EastAsianWidth".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(EastAsianWidth::ALL_VALUES),
        },
        Prop {
            name: "LineBreak".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(LineBreak::ALL_VALUES),
        },
        Prop {
            name: "GraphemeClusterBreak".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(GraphemeClusterBreak::ALL_VALUES),
        },
        Prop {
            name: "WordBreak".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(WordBreak::ALL_VALUES),
        },
        Prop {
            name: "SentenceBreak".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(SentenceBreak::ALL_VALUES),
        },
        Prop {
            name: "CanonicalCombiningClass".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(CanonicalCombiningClass::ALL_VALUES),
        },
        Prop {
            name: "IndicSyllabicCategory".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(IndicSyllabicCategory::ALL_VALUES),
        },
        Prop {
            name: "IndicConjunctBreak".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(IndicConjunctBreak::ALL_VALUES),
        },
        Prop {
            name: "JoiningGroup".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(JoiningGroup::ALL_VALUES),
        },
        Prop {
            name: "JoiningType".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(JoiningType::ALL_VALUES),
        },
        Prop {
            name: "GeneralCategory".into(),
            is_open: false,
            int_type: "u8",
            variants: variants(GeneralCategory::ALL_VALUES),
        },
        Prop {
            name: "VerticalOrientation".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(VerticalOrientation::ALL_VALUES),
        },
    ];

    {
        let mut path_buf = path_buf.clone();
        path_buf.push("properties_enums.rs");
        let mut file = File::create(&path_buf).unwrap();
        use std::io::Write;
        writeln!(&mut file, "{}", PropertiesEnums { props }).unwrap();
    }

    {
        let mut path_buf = path_buf.clone();
        path_buf.push("properties_maps.rs");
        let mut file = File::create(&path_buf).unwrap();
        use std::io::Write;
        writeln!(&mut file, "{}", PropertiesMaps { props }).unwrap();
    }

    {
        let mut path_buf = path_buf.clone();
        path_buf.push("properties_names.rs");
        let mut file = File::create(&path_buf).unwrap();
        use std::io::Write;
        writeln!(&mut file, "{}", PropertiesNames { props }).unwrap();
    }

    let binary_props = &[
        BinaryProp {
            property_name: AsciiHexDigit::NAME,
            struct_name: stringify!(AsciiHexDigit),
        },
        BinaryProp {
            property_name: Alnum::NAME,
            struct_name: stringify!(Alnum),
        },
        BinaryProp {
            property_name: Alphabetic::NAME,
            struct_name: stringify!(Alphabetic),
        },
        BinaryProp {
            property_name: BidiControl::NAME,
            struct_name: stringify!(BidiControl),
        },
        BinaryProp {
            property_name: BidiMirrored::NAME,
            struct_name: stringify!(BidiMirrored),
        },
        BinaryProp {
            property_name: Blank::NAME,
            struct_name: stringify!(Blank),
        },
        BinaryProp {
            property_name: Cased::NAME,
            struct_name: stringify!(Cased),
        },
        BinaryProp {
            property_name: CaseIgnorable::NAME,
            struct_name: stringify!(CaseIgnorable),
        },
        BinaryProp {
            property_name: FullCompositionExclusion::NAME,
            struct_name: stringify!(FullCompositionExclusion),
        },
        BinaryProp {
            property_name: ChangesWhenCasefolded::NAME,
            struct_name: stringify!(ChangesWhenCasefolded),
        },
        BinaryProp {
            property_name: ChangesWhenCasemapped::NAME,
            struct_name: stringify!(ChangesWhenCasemapped),
        },
        BinaryProp {
            property_name: ChangesWhenNfkcCasefolded::NAME,
            struct_name: stringify!(ChangesWhenNfkcCasefolded),
        },
        BinaryProp {
            property_name: ChangesWhenLowercased::NAME,
            struct_name: stringify!(ChangesWhenLowercased),
        },
        BinaryProp {
            property_name: ChangesWhenTitlecased::NAME,
            struct_name: stringify!(ChangesWhenTitlecased),
        },
        BinaryProp {
            property_name: ChangesWhenUppercased::NAME,
            struct_name: stringify!(ChangesWhenUppercased),
        },
        BinaryProp {
            property_name: Dash::NAME,
            struct_name: stringify!(Dash),
        },
        BinaryProp {
            property_name: Deprecated::NAME,
            struct_name: stringify!(Deprecated),
        },
        BinaryProp {
            property_name: DefaultIgnorableCodePoint::NAME,
            struct_name: stringify!(DefaultIgnorableCodePoint),
        },
        BinaryProp {
            property_name: Diacritic::NAME,
            struct_name: stringify!(Diacritic),
        },
        BinaryProp {
            property_name: EmojiModifierBase::NAME,
            struct_name: stringify!(EmojiModifierBase),
        },
        BinaryProp {
            property_name: EmojiComponent::NAME,
            struct_name: stringify!(EmojiComponent),
        },
        BinaryProp {
            property_name: EmojiModifier::NAME,
            struct_name: stringify!(EmojiModifier),
        },
        BinaryProp {
            property_name: Emoji::NAME,
            struct_name: stringify!(Emoji),
        },
        BinaryProp {
            property_name: EmojiPresentation::NAME,
            struct_name: stringify!(EmojiPresentation),
        },
        BinaryProp {
            property_name: Extender::NAME,
            struct_name: stringify!(Extender),
        },
        BinaryProp {
            property_name: ExtendedPictographic::NAME,
            struct_name: stringify!(ExtendedPictographic),
        },
        BinaryProp {
            property_name: Graph::NAME,
            struct_name: stringify!(Graph),
        },
        BinaryProp {
            property_name: GraphemeBase::NAME,
            struct_name: stringify!(GraphemeBase),
        },
        BinaryProp {
            property_name: GraphemeExtend::NAME,
            struct_name: stringify!(GraphemeExtend),
        },
        BinaryProp {
            property_name: GraphemeLink::NAME,
            struct_name: stringify!(GraphemeLink),
        },
        BinaryProp {
            property_name: HexDigit::NAME,
            struct_name: stringify!(HexDigit),
        },
        BinaryProp {
            property_name: Hyphen::NAME,
            struct_name: stringify!(Hyphen),
        },
        BinaryProp {
            property_name: IdCompatMathContinue::NAME,
            struct_name: stringify!(IdCompatMathContinue),
        },
        BinaryProp {
            property_name: IdCompatMathStart::NAME,
            struct_name: stringify!(IdCompatMathStart),
        },
        BinaryProp {
            property_name: IdContinue::NAME,
            struct_name: stringify!(IdContinue),
        },
        BinaryProp {
            property_name: Ideographic::NAME,
            struct_name: stringify!(Ideographic),
        },
        BinaryProp {
            property_name: IdStart::NAME,
            struct_name: stringify!(IdStart),
        },
        BinaryProp {
            property_name: IdsBinaryOperator::NAME,
            struct_name: stringify!(IdsBinaryOperator),
        },
        BinaryProp {
            property_name: IdsTrinaryOperator::NAME,
            struct_name: stringify!(IdsTrinaryOperator),
        },
        BinaryProp {
            property_name: IdsUnaryOperator::NAME,
            struct_name: stringify!(IdsUnaryOperator),
        },
        BinaryProp {
            property_name: JoinControl::NAME,
            struct_name: stringify!(JoinControl),
        },
        BinaryProp {
            property_name: LogicalOrderException::NAME,
            struct_name: stringify!(LogicalOrderException),
        },
        BinaryProp {
            property_name: Lowercase::NAME,
            struct_name: stringify!(Lowercase),
        },
        BinaryProp {
            property_name: Math::NAME,
            struct_name: stringify!(Math),
        },
        BinaryProp {
            property_name: ModifierCombiningMark::NAME,
            struct_name: stringify!(ModifierCombiningMark),
        },
        BinaryProp {
            property_name: NoncharacterCodePoint::NAME,
            struct_name: stringify!(NoncharacterCodePoint),
        },
        BinaryProp {
            property_name: NfcInert::NAME,
            struct_name: stringify!(NfcInert),
        },
        BinaryProp {
            property_name: NfdInert::NAME,
            struct_name: stringify!(NfdInert),
        },
        BinaryProp {
            property_name: NfkcInert::NAME,
            struct_name: stringify!(NfkcInert),
        },
        BinaryProp {
            property_name: NfkdInert::NAME,
            struct_name: stringify!(NfkdInert),
        },
        BinaryProp {
            property_name: PatternSyntax::NAME,
            struct_name: stringify!(PatternSyntax),
        },
        BinaryProp {
            property_name: PatternWhiteSpace::NAME,
            struct_name: stringify!(PatternWhiteSpace),
        },
        BinaryProp {
            property_name: PrependedConcatenationMark::NAME,
            struct_name: stringify!(PrependedConcatenationMark),
        },
        BinaryProp {
            property_name: Print::NAME,
            struct_name: stringify!(Print),
        },
        BinaryProp {
            property_name: QuotationMark::NAME,
            struct_name: stringify!(QuotationMark),
        },
        BinaryProp {
            property_name: Radical::NAME,
            struct_name: stringify!(Radical),
        },
        BinaryProp {
            property_name: RegionalIndicator::NAME,
            struct_name: stringify!(RegionalIndicator),
        },
        BinaryProp {
            property_name: SoftDotted::NAME,
            struct_name: stringify!(SoftDotted),
        },
        BinaryProp {
            property_name: SegmentStarter::NAME,
            struct_name: stringify!(SegmentStarter),
        },
        BinaryProp {
            property_name: CaseSensitive::NAME,
            struct_name: stringify!(CaseSensitive),
        },
        BinaryProp {
            property_name: SentenceTerminal::NAME,
            struct_name: stringify!(SentenceTerminal),
        },
        BinaryProp {
            property_name: TerminalPunctuation::NAME,
            struct_name: stringify!(TerminalPunctuation),
        },
        BinaryProp {
            property_name: UnifiedIdeograph::NAME,
            struct_name: stringify!(UnifiedIdeograph),
        },
        BinaryProp {
            property_name: Uppercase::NAME,
            struct_name: stringify!(Uppercase),
        },
        BinaryProp {
            property_name: VariationSelector::NAME,
            struct_name: stringify!(VariationSelector),
        },
        BinaryProp {
            property_name: WhiteSpace::NAME,
            struct_name: stringify!(WhiteSpace),
        },
        BinaryProp {
            property_name: Xdigit::NAME,
            struct_name: stringify!(Xdigit),
        },
        BinaryProp {
            property_name: XidContinue::NAME,
            struct_name: stringify!(XidContinue),
        },
        BinaryProp {
            property_name: XidStart::NAME,
            struct_name: stringify!(XidStart),
        },
    ];

    {
        let path_buf = path_buf.join("properties_sets.rs");
        let mut file = File::create(&path_buf).unwrap();
        use std::io::Write;
        writeln!(&mut file, "{}", PropertiesSets { binary_props }).unwrap();
    }
}
