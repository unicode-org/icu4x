// This file is part of ICU4X. For terms of use, please see the file
// called LICENSE at the top level of the ICU4X source tree
// (online at: https://github.com/unicode-org/icu4x/blob/main/LICENSE ).

use std::collections::BTreeSet;
use std::{fs::File, path::PathBuf};

use askama::Template;
use icu::properties::props::*;

const GENERATED_BY: &str = std::concat!("@generated by ", std::file!());

#[derive(Template)]
#[template(path = "properties_enums.rs.jinja")]
struct PropertiesEnums<'a> {
    props: &'a [Prop],
}

struct Prop {
    name: String,
    is_open: bool,
    int_type: &'static str,
    variants: Vec<(String, u32)>,
}

impl Prop {
    fn kind(&self) -> &'static str {
        if self.is_open {
            "Struct"
        } else {
            "Enum"
        }
    }

    fn variant_kind(&self) -> &'static str {
        if self.is_open {
            "AssociatedConstantInStruct"
        } else {
            "EnumVariant"
        }
    }

    fn is_default(&self, discriminant: u32) -> bool {
        if let Some(&(_, d)) = self
            .variants
            .iter()
            .find(|(n, _)| n == "Unknown" || n == "Unassigned")
        {
            discriminant == d
        } else {
            discriminant == 0
        }
    }
}

pub fn main() {
    let mut path_buf = PathBuf::new();
    path_buf.push(env!("CARGO_MANIFEST_DIR"));
    path_buf.push("../../../ffi/capi/src");

    fn variants(values: &[impl NamedEnumeratedProperty]) -> Vec<(String, u32)> {
        values
            .iter()
            .map(|v| {
                (
                    v.long_name()
                        .replace('_', "")
                        .replace("Ethiopic", "Ethiopian")
                        .replace("Aran", "Nastaliq")
                        .replace("LVSyllable", "LeadingVowelSyllable")
                        .replace("LVTSyllable", "LeadingVowelTrailingSyllable"),
                    v.to_u32(),
                )
            })
            .collect()
    }

    let props = &[
        Prop {
            name: "BidiClass".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(BidiClass::ALL_VALUES),
        },
        Prop {
            name: "NumericType".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(NumericType::ALL_VALUES),
        },
        Prop {
            name: "Script".into(),
            is_open: true,
            int_type: "u16",
            #[allow(deprecated)]
            variants: variants(Script::ALL_VALUES)
                .into_iter()
                .chain([("Chisoi".into(), 254)])
                .collect::<BTreeSet<_>>()
                .into_iter()
                .collect(),
        },
        Prop {
            name: "HangulSyllableType".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(HangulSyllableType::ALL_VALUES),
        },
        Prop {
            name: "EastAsianWidth".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(EastAsianWidth::ALL_VALUES),
        },
        Prop {
            name: "LineBreak".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(LineBreak::ALL_VALUES),
        },
        Prop {
            name: "GraphemeClusterBreak".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(GraphemeClusterBreak::ALL_VALUES),
        },
        Prop {
            name: "WordBreak".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(WordBreak::ALL_VALUES),
        },
        Prop {
            name: "SentenceBreak".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(SentenceBreak::ALL_VALUES),
        },
        Prop {
            name: "CanonicalCombiningClass".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(CanonicalCombiningClass::ALL_VALUES),
        },
        Prop {
            name: "IndicSyllabicCategory".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(IndicSyllabicCategory::ALL_VALUES),
        },
        Prop {
            name: "IndicConjunctBreak".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(IndicConjunctBreak::ALL_VALUES),
        },
        Prop {
            name: "JoiningGroup".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(JoiningGroup::ALL_VALUES),
        },
        Prop {
            name: "JoiningType".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(JoiningType::ALL_VALUES),
        },
        Prop {
            name: "GeneralCategory".into(),
            is_open: false,
            int_type: "u8",
            variants: variants(GeneralCategory::ALL_VALUES),
        },
        Prop {
            name: "VerticalOrientation".into(),
            is_open: true,
            int_type: "u8",
            variants: variants(VerticalOrientation::ALL_VALUES),
        },
    ];

    {
        let mut path_buf = path_buf.clone();
        path_buf.push("properties_enums.rs");
        let mut file = File::create(&path_buf).unwrap();
        use std::io::Write;
        writeln!(&mut file, "{}", PropertiesEnums { props }).unwrap();
    }
}
