// This file is part of ICU4X. For terms of use, please see the file
// called LICENSE at the top level of the ICU4X source tree
// (online at: https://github.com/unicode-org/icu4x/blob/main/LICENSE ).

use crlify::BufWriterWithLineEndingFix;
use icu_datagen::baked_exporter::*;
use icu_datagen::blob_exporter::*;
use icu_datagen::fs_exporter::serializers::*;
use icu_datagen::fs_exporter::*;
use icu_datagen::prelude::*;
use icu_provider::datagen::MultiExporter;
use rust_format::*;
use std::fs::File;
use std::io::Write;
use std::path::Path;

include!("../../locales.rs.data");

fn main() {
    #![allow(deprecated)] // want to keep old datagen code path covered

    simple_logger::SimpleLogger::new()
        .env()
        .with_level(log::LevelFilter::Info)
        .init()
        .unwrap();

    let out_dir = Path::new(concat!(
        core::env!("CARGO_MANIFEST_DIR"),
        "/../../provider/testdata/data/"
    ));

    let source = SourceData::offline()
        .with_cldr(repodata::paths::cldr(), Default::default())
        .unwrap()
        .with_icuexport(repodata::paths::icuexport())
        .unwrap()
        .with_segmenter_lstm(repodata::paths::lstm())
        .unwrap();

    let json_out = Box::new(
        FilesystemExporter::try_new(Box::new(Json::pretty()), {
            let mut options = ExporterOptions::default();
            options.root = repodata::paths::json();
            options.overwrite = OverwriteOption::RemoveAndReplace;
            options.fingerprint = true;
            options
        })
        .unwrap(),
    );

    let postcard_out = Box::new(
        FilesystemExporter::try_new(Box::<Postcard>::default(), {
            let mut options = ExporterOptions::default();
            options.root = out_dir.join("postcard");
            options.overwrite = OverwriteOption::RemoveAndReplace;
            options.fingerprint = true;
            options
        })
        .unwrap(),
    );

    let blob_out = Box::new(BlobExporter::new_with_sink(Box::new(
        File::create(out_dir.join("testdata.postcard")).unwrap(),
    )));

    let mod_out = Box::new(
        BakedExporter::new(out_dir.join("baked"), {
            let mut options = Options::default();
            options.insert_feature_gates = true;
            options.use_separate_crates = true;
            options.overwrite = true;
            options.pretty = true;
            options
        })
        .unwrap(),
    );

    let mut options = options::Options::default();
    options.locales = options::LocaleInclude::Explicit(LOCALES.iter().cloned().collect());

    DatagenProvider::try_new(options, source)
        .unwrap()
        .export(
            icu_datagen::all_keys_with_experimental()
                .into_iter()
                .chain([icu_provider::hello_world::HelloWorldV1Marker::KEY])
                .collect(),
            MultiExporter::new(vec![json_out, blob_out, mod_out, postcard_out]),
        )
        .unwrap();

    let mut metadata =
        BufWriterWithLineEndingFix::new(File::create(out_dir.join("metadata.rs.data")).unwrap());

    metadata
        .write_all(
            "\
             // DO NOT EDIT\n\
             // This file is generated by `make-testdata` from\n\
             // * tools/testdata-scripts/locales.rs.data,\n\
             // * `icu_datagen::SourceData::LATEST_TESTED_*`.\n\
             \n\
            "
            .as_bytes(),
        )
        .unwrap();

    let locales = databake::Bake::bake(LOCALES, &Default::default());
    // repodata corresponds to these tags.
    let cldr_tag = SourceData::LATEST_TESTED_CLDR_TAG;
    let icu_tag = SourceData::LATEST_TESTED_ICUEXPORT_TAG;
    let lstm_tag = SourceData::LATEST_TESTED_SEGMENTER_LSTM_TAG;

    metadata
        .write_all(
            RustFmt::new()
                .format_tokens(quote::quote! {
                    pub const LOCALES: &[icu_locid::LanguageIdentifier] = &#locales;
                    pub const CLDR_TAG: &str = #cldr_tag;
                    pub const ICUEXPORT_TAG: &str = #icu_tag;
                    pub const SEGMENTER_LSTM_TAG: &str = #lstm_tag;
                })
                .unwrap()
                .as_bytes(),
        )
        .unwrap();
}
