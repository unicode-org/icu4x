diff --git a/components/datetime/src/lib.rs b/components/datetime/src/lib.rs
index 3a74552..bc56d43 100644
--- a/components/datetime/src/lib.rs
+++ b/components/datetime/src/lib.rs
@@ -163,7 +163,7 @@ impl<'d> DateTimeFormat<'d> {
     ///
     /// assert_eq!(dtf.is_ok(), true);
     /// ```
-    pub fn try_new<T: Into<Locale>, D: DataProvider<'d, provider::gregory::DatesV1> + ?Sized>(
+    pub fn try_new<T: Into<Locale>, D: DataProvider<'d, provider::gregory::DatesV2<'d>> + ?Sized>(
         locale: T,
         data_provider: &D,
         options: &DateTimeFormatOptions,
@@ -182,6 +182,7 @@ impl<'d> DateTimeFormat<'d> {
             .payload
             .take()?;
 
+        let p2 = data.patterns.get_pattern_for_date_time2();
         let pattern = data
             .patterns
             .get_pattern_for_options(options)?
diff --git a/components/datetime/src/provider/gregory.rs b/components/datetime/src/provider/gregory.rs
index 35382bd..606441a 100644
--- a/components/datetime/src/provider/gregory.rs
+++ b/components/datetime/src/provider/gregory.rs
@@ -15,6 +15,18 @@ pub struct DatesV1 {
     pub patterns: PatternsV1,
 }
 
+#[derive(Debug, PartialEq, Clone, Default)]
+#[cfg_attr(
+    feature = "provider_serde",
+    derive(serde::Serialize, serde::Deserialize)
+)]
+pub struct DatesV2<'s> {
+    pub symbols: DateSymbolsV1,
+
+    #[serde(borrow)]
+    pub patterns: PatternsV2<'s>,
+}
+
 #[derive(Debug, PartialEq, Clone, Default)]
 #[cfg_attr(
     feature = "provider_serde",
@@ -41,6 +53,20 @@ pub struct PatternsV1 {
     pub date_time: patterns::DateTimeFormatsV1,
 }
 
+#[derive(Debug, PartialEq, Clone, Default)]
+#[cfg_attr(
+    feature = "provider_serde",
+    derive(serde::Serialize, serde::Deserialize)
+)]
+pub struct PatternsV2<'s> {
+    pub date: patterns::LengthPatternsV1,
+
+    pub time: patterns::LengthPatternsV1,
+
+    #[serde(borrow)]
+    pub date_time: patterns::DateTimeFormatsV2<'s>,
+}
+
 macro_rules! symbols {
         ($name: ident, $expr: ty) => {
             pub mod $name {
@@ -157,6 +183,22 @@ pub mod patterns {
         pub short: Cow<'static, str>,
     }
 
+    #[derive(Debug, PartialEq, Clone, Default)]
+    #[cfg_attr(
+        feature = "provider_serde",
+        derive(serde::Serialize, serde::Deserialize)
+    )]
+    pub struct LengthPatternsV2<'s> {
+        #[serde(borrow)]
+        pub full: Cow<'s, str>,
+        #[serde(borrow)]
+        pub long: Cow<'s, str>,
+        #[serde(borrow)]
+        pub medium: Cow<'s, str>,
+        #[serde(borrow)]
+        pub short: Cow<'s, str>,
+    }
+
     /// This struct is a public wrapper around the internal Pattern struct. This allows
     /// access to the serialization and deserialization capabilities, without exposing the
     /// internals of the pattern machinery.
@@ -228,4 +270,15 @@ pub mod patterns {
         pub length_patterns: LengthPatternsV1,
         pub skeletons: SkeletonsV1,
     }
+
+    #[derive(Debug, PartialEq, Clone, Default)]
+    #[cfg_attr(
+        feature = "provider_serde",
+        derive(serde::Serialize, serde::Deserialize)
+    )]
+    pub struct DateTimeFormatsV2<'s> {
+        #[serde(borrow)]
+        pub length_patterns: LengthPatternsV2<'s>,
+        pub skeletons: SkeletonsV1,
+    }
 }
diff --git a/components/datetime/src/provider/helpers.rs b/components/datetime/src/provider/helpers.rs
index 73ead0d..ea44403 100644
--- a/components/datetime/src/provider/helpers.rs
+++ b/components/datetime/src/provider/helpers.rs
@@ -12,7 +12,7 @@ use std::borrow::Cow;
 
 type Result<T> = std::result::Result<T, DateTimeFormatError>;
 
-pub trait DateTimePatterns {
+pub trait DateTimePatterns<'s> {
     fn get_pattern_for_options(&self, options: &DateTimeFormatOptions) -> Result<Option<Pattern>>;
     fn get_pattern_for_length_bag(&self, length: &length::Bag) -> Result<Option<Pattern>>;
     fn get_pattern_for_date_length(&self, length: length::Date) -> Result<Pattern>;
@@ -23,6 +23,7 @@ pub trait DateTimePatterns {
         date: Pattern,
         time: Pattern,
     ) -> Result<Pattern>;
+    fn get_pattern_for_date_time2(&'s self) -> Result<Pattern>;
 }
 
 pub trait DateTimeSymbols {
@@ -47,7 +48,7 @@ pub trait DateTimeSymbols {
     ) -> &Cow<str>;
 }
 
-impl DateTimePatterns for provider::gregory::PatternsV1 {
+impl<'s> DateTimePatterns<'s> for provider::gregory::PatternsV2<'s> {
     fn get_pattern_for_options(&self, options: &DateTimeFormatOptions) -> Result<Option<Pattern>> {
         match options {
             DateTimeFormatOptions::Length(bag) => self.get_pattern_for_length_bag(bag),
@@ -107,6 +108,21 @@ impl DateTimePatterns for provider::gregory::PatternsV1 {
         };
         Ok(Pattern::from_bytes(s)?)
     }
+
+    fn get_pattern_for_date_time2(&'s self) -> Result<Pattern> {
+        let date_time = &self.date_time;
+        let s = match length::Date::Full {
+            length::Date::Full => &date_time.length_patterns.full,
+            length::Date::Long => &date_time.length_patterns.long,
+            length::Date::Medium => &date_time.length_patterns.medium,
+            length::Date::Short => &date_time.length_patterns.short,
+        };
+        match s {
+            Cow::Owned(o) => println!("Owned: {:?}", o),
+            Cow::Borrowed(b) => println!("Borrowed: {:?}", b),
+        }
+        panic!();
+    }
 }
 
 impl DateTimeSymbols for provider::gregory::DateSymbolsV1 {
diff --git a/components/datetime/tests/datetime.rs b/components/datetime/tests/datetime.rs
index 1163cef..e69de29 100644
--- a/components/datetime/tests/datetime.rs
+++ b/components/datetime/tests/datetime.rs
@@ -1,120 +0,0 @@
-// This file is part of ICU4X. For terms of use, please see the file
-// called LICENSE at the top level of the ICU4X source tree
-// (online at: https://github.com/unicode-org/icu4x/blob/main/LICENSE ).
-
-#![cfg(feature = "serde")]
-
-mod fixtures;
-mod patterns;
-
-use icu_datetime::{mock::MockDateTime, DateTimeFormatOptions};
-use icu_datetime::{
-    provider::{gregory::DatesV1, key::GREGORY_V1},
-    DateTimeFormat,
-};
-use icu_locid::{LanguageIdentifier, Locale};
-use icu_provider::{
-    struct_provider::StructProvider, DataProvider, DataRequest, ResourceOptions, ResourcePath,
-};
-use std::{borrow::Cow, fmt::Write};
-
-fn test_fixture(fixture_name: &str) {
-    let provider = icu_testdata::get_provider();
-
-    for fx in fixtures::get_fixture(fixture_name)
-        .expect("Unable to get fixture.")
-        .0
-    {
-        let locale: Locale = fx.input.locale.parse().unwrap();
-        let options = fixtures::get_options(&fx.input.options);
-        let dtf = DateTimeFormat::try_new(locale, &provider, &options).unwrap();
-
-        let value: MockDateTime = fx.input.value.parse().unwrap();
-
-        let result = dtf.format_to_string(&value);
-        assert_eq!(result, fx.output.value);
-
-        let mut s = String::new();
-        dtf.format_to_write(&mut s, &value).unwrap();
-        assert_eq!(s, fx.output.value);
-
-        let fdt = dtf.format(&value);
-        assert_eq!(fdt.to_string(), fx.output.value);
-
-        let mut s = String::new();
-        write!(s, "{}", fdt).unwrap();
-        assert_eq!(s, fx.output.value);
-    }
-}
-
-#[test]
-fn test_dayperiod_patterns() {
-    use patterns::structs::Expectation;
-    let provider = icu_testdata::get_provider();
-    let format_options = DateTimeFormatOptions::default();
-    for test in patterns::get_tests("dayperiods").unwrap().0 {
-        let langid: LanguageIdentifier = test.locale.parse().unwrap();
-        let mut data: Cow<DatesV1> = provider
-            .load_payload(&DataRequest {
-                resource_path: ResourcePath {
-                    key: GREGORY_V1,
-                    options: ResourceOptions {
-                        variant: None,
-                        langid: Some(langid.clone()),
-                    },
-                },
-            })
-            .unwrap()
-            .payload
-            .take()
-            .unwrap();
-        *data
-            .to_mut()
-            .patterns
-            .date_time
-            .length_patterns
-            .long
-            .to_mut() = String::from("{0}");
-        for test_case in &test.test_cases {
-            for dt_input in &test_case.date_times {
-                let date_time: MockDateTime = dt_input.parse().unwrap();
-                for Expectation { patterns, expected } in &test_case.expectations {
-                    for pattern_input in patterns {
-                        *data.to_mut().patterns.time.long.to_mut() = String::from(pattern_input);
-                        let provider = StructProvider {
-                            key: GREGORY_V1,
-                            data: data.as_ref(),
-                        };
-                        let dtf =
-                            DateTimeFormat::try_new(langid.clone(), &provider, &format_options)
-                                .unwrap();
-                        assert_eq!(
-                            dtf.format(&date_time).to_string(),
-                            *expected,
-                            "\n\
-                            locale:   `{}`,\n\
-                            datetime: `{}`,\n\
-                            pattern:  `{}`",
-                            langid,
-                            dt_input,
-                            pattern_input,
-                        );
-                    }
-                }
-            }
-        }
-    }
-}
-
-#[test]
-fn test_length_fixtures() {
-    test_fixture("lengths");
-}
-
-// Expected panic: 'not implemented', components/datetime/src/provider.rs:49:53
-// https://github.com/unicode-org/icu4x/issues/272
-#[test]
-#[should_panic]
-fn test_components_fixtures() {
-    test_fixture("components");
-}
diff --git a/components/provider_cldr/src/transform/dates.rs b/components/provider_cldr/src/transform/dates.rs
index d767bbb..79e4795 100644
--- a/components/provider_cldr/src/transform/dates.rs
+++ b/components/provider_cldr/src/transform/dates.rs
@@ -86,7 +86,33 @@ impl<'d> DataProvider<'d, gregory::DatesV1> for DatesProvider<'d> {
     }
 }
 
-icu_provider::impl_dyn_provider!(DatesProvider<'d>, gregory::DatesV1, SERDE_SE, 'd, 's);
+impl<'d, 's> DataProvider<'d, gregory::DatesV2<'s>> for DatesProvider<'d> {
+    fn load_payload(
+        &self,
+        req: &DataRequest,
+    ) -> Result<DataResponse<'d, gregory::DatesV2<'s>>, DataError> {
+        DatesProvider::supports_key(&req.resource_path.key)?;
+        let cldr_langid: CldrLangID = req.try_langid()?.clone().into();
+        let dates = match self
+            .data
+            .binary_search_by_key(&&cldr_langid, |(lid, _)| lid)
+        {
+            Ok(idx) => &self.data[idx].1.dates,
+            Err(_) => return Err(DataError::UnavailableResourceOptions(req.clone())),
+        };
+        Ok(DataResponse {
+            metadata: DataResponseMetadata {
+                data_langid: req.resource_path.options.langid.clone(),
+            },
+            payload: DataPayload {
+                cow: Some(Cow::Owned(gregory::DatesV2::from(dates))),
+            },
+        })
+    }
+}
+
+// icu_provider::impl_dyn_provider!(DatesProvider<'d>, gregory::DatesV1, SERDE_SE, 'd, 's);
+icu_provider::impl_dyn_provider!(DatesProvider<'d>, gregory::DatesV2, SERDE_SE, 'd, 's);
 
 impl<'d> IterableDataProviderCore for DatesProvider<'d> {
     fn supported_options_for_key(
@@ -118,6 +144,17 @@ impl From<&cldr_json::LengthPatterns> for gregory::patterns::LengthPatternsV1 {
     }
 }
 
+impl From<&cldr_json::LengthPatterns> for gregory::patterns::LengthPatternsV2<'_> {
+    fn from(other: &cldr_json::LengthPatterns) -> Self {
+        Self {
+            full: Cow::Owned(other.full.get_pattern().clone()),
+            long: Cow::Owned(other.long.get_pattern().clone()),
+            medium: Cow::Owned(other.medium.get_pattern().clone()),
+            short: Cow::Owned(other.short.get_pattern().clone()),
+        }
+    }
+}
+
 impl From<&cldr_json::DateTimeFormats> for gregory::patterns::DateTimeFormatsV1 {
     fn from(other: &cldr_json::DateTimeFormats) -> Self {
         use gregory::patterns::{PatternV1, SkeletonV1, SkeletonsV1};
@@ -179,6 +216,67 @@ impl From<&cldr_json::DateTimeFormats> for gregory::patterns::DateTimeFormatsV1
     }
 }
 
+impl From<&cldr_json::DateTimeFormats> for gregory::patterns::DateTimeFormatsV2<'_> {
+    fn from(other: &cldr_json::DateTimeFormats) -> Self {
+        use gregory::patterns::{PatternV1, SkeletonV1, SkeletonsV1};
+        use litemap::LiteMap;
+
+        // TODO(#308): Support numbering system variations. We currently throw them away.
+        Self {
+            length_patterns: gregory::patterns::LengthPatternsV2 {
+                full: Cow::Owned(other.full.get_pattern().clone()),
+                long: Cow::Owned(other.long.get_pattern().clone()),
+                medium: Cow::Owned(other.medium.get_pattern().clone()),
+                short: Cow::Owned(other.short.get_pattern().clone()),
+            },
+            skeletons: {
+                let mut skeletons = SkeletonsV1(LiteMap::new());
+
+                // The CLDR keys for available_formats can have duplicate skeletons with either
+                // an additional variant, or with multiple variants for different plurals.
+                for (skeleton_str, pattern_str) in other.available_formats.0.iter() {
+                    let mut unique_skeleton = None;
+                    let mut variant_parts = Vec::new();
+
+                    for part in skeleton_str.split('-') {
+                        match unique_skeleton {
+                            None => {
+                                unique_skeleton = Some(part);
+                            }
+                            Some(_) => variant_parts.push(part),
+                        }
+                    }
+
+                    let unique_skeleton = unique_skeleton.expect("Expected to find a skeleton.");
+
+                    let skeleton_fields_v1 = match SkeletonV1::try_from(unique_skeleton) {
+                        Ok(s) => s,
+                        Err(err) => match err {
+                            // Ignore unimplemented fields for now.
+                            SkeletonError::SymbolUnimplemented(_) => continue,
+                            _ => panic!("{:?} {}", unique_skeleton, err),
+                        },
+                    };
+
+                    if !variant_parts.is_empty() {
+                        unimplemented!(
+                            "This skeleton string is not yet supported: {:?}",
+                            skeleton_str
+                        );
+                    }
+
+                    let pattern_v1 = PatternV1::try_from(pattern_str as &str)
+                        .expect("Unable to parse a pattern");
+
+                    skeletons.0.insert(skeleton_fields_v1, pattern_v1);
+                }
+
+                skeletons
+            },
+        }
+    }
+}
+
 impl From<&cldr_json::Dates> for gregory::DatesV1 {
     fn from(other: &cldr_json::Dates) -> Self {
         Self {
@@ -196,6 +294,23 @@ impl From<&cldr_json::Dates> for gregory::DatesV1 {
     }
 }
 
+impl From<&cldr_json::Dates> for gregory::DatesV2<'_> {
+    fn from(other: &cldr_json::Dates) -> Self {
+        Self {
+            symbols: gregory::DateSymbolsV1 {
+                months: (&other.calendars.gregorian.months).into(),
+                weekdays: (&other.calendars.gregorian.days).into(),
+                day_periods: (&other.calendars.gregorian.day_periods).into(),
+            },
+            patterns: gregory::PatternsV2 {
+                date: (&other.calendars.gregorian.date_formats).into(),
+                time: (&other.calendars.gregorian.time_formats).into(),
+                date_time: (&other.calendars.gregorian.date_time_formats).into(),
+            },
+        }
+    }
+}
+
 macro_rules! symbols_from {
     ([$name: ident, $name2: ident $(,)?], [ $($element: ident),+ $(,)? ] $(,)?) => {
         impl From<&cldr_json::$name::Symbols> for gregory::$name2::SymbolsV1 {
